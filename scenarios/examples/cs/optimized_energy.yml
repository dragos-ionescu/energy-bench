implementation: cs
name: matrix-multiplication-optimized
description: |
    Create two square matrices of size NÃ—N.
    Each cell within these two matrices will be initialized with the sum of their row and column indices.
    Multiply the two matrices and output the contents of the last cell.
code: |
    using System;
    using System.Threading.Tasks;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Numerics;

    public class Program {
        // L1 and L2 cache-friendly block sizes
        private const int L1_BLOCK_SIZE = 64;
        private const int L2_BLOCK_SIZE = 256;

        public static void Main(string[] args) {
            int n = int.Parse(args[0]);

            // Use aligned memory to improve cache performance
            double[] A = GC.AllocateArray<double>(n * n, true);
            double[] B = GC.AllocateArray<double>(n * n, true);
            double[] C = GC.AllocateArray<double>(n * n, true);

            // Initialize matrices in parallel
            Parallel.For(0, n, i => {
                for (int j = 0; j < n; j++) {
                    A[i*n + j] = B[i*n + j] = i + j;
                }
            });

            // Use all available cores but limit to physical cores where possible
            int numThreads = Math.Min(Environment.ProcessorCount, 6);
            ParallelOptions options = new ParallelOptions {
                MaxDegreeOfParallelism = numThreads
            };

            // Three-level blocking approach using parallel processing
            Parallel.For(0, (n + L2_BLOCK_SIZE - 1) / L2_BLOCK_SIZE, options, i2Block => {
                int i2 = i2Block * L2_BLOCK_SIZE;

                for (int j2 = 0; j2 < n; j2 += L2_BLOCK_SIZE) {
                    for (int k2 = 0; k2 < n; k2 += L2_BLOCK_SIZE) {
                        // Process L1 cache-sized blocks
                        for (int i1 = i2; i1 < i2 + L2_BLOCK_SIZE && i1 < n; i1 += L1_BLOCK_SIZE) {
                            for (int j1 = j2; j1 < j2 + L2_BLOCK_SIZE && j1 < n; j1 += L1_BLOCK_SIZE) {
                                for (int k1 = k2; k1 < k2 + L2_BLOCK_SIZE && k1 < n; k1 += L1_BLOCK_SIZE) {
                                    // Process individual elements within L1 block
                                    // i-k-j ordering for better locality
                                    for (int i = i1; i < i1 + L1_BLOCK_SIZE && i < n; i++) {
                                        for (int k = k1; k < k1 + L1_BLOCK_SIZE && k < n; k++) {
                                            double a_ik = A[i*n + k];

                                            // Vectorization-friendly inner loop
                                            for (int j = j1; j < j1 + L1_BLOCK_SIZE && j < n; j++) {
                                                C[i*n + j] += a_ik * B[k*n + j];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            });

            Console.WriteLine($"{C[n*n - 1]:F0}");
        }
    }
dependencies:
    - name: dotnet-sdk
target_framework: net9.0
options:
    - -c Release
    - -p:OutputType=Exe
    - -p:ImplicitUsings=enable
    - -p:Nullable=enable
    - -p:AllowUnsafeBlocks=true
    - -p:ServerGarbageCollection=true
    - -p:ConcurrentGarbageCollection=true
    - -p:OptimizationPreference=Speed
    - -p:IlcInstructionSet=native
---
args: [200]
expected_stdout: |
    18487100
