implementation: openjdk
name: fannkuch-redux
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/fannkuchredux.html#fannkuchredux
    ## Background
    The fannkuch benchmark is defined by programs in [pdf][Performing Lisp Analysis of the FANNKUCH Benchmark,](https://dl.acm.org/doi/pdf/10.1145/382109.382124) Kenneth R. Anderson and Duane Rettig. FANNKUCH is an abbreviation for the German word Pfannkuchen, or pancakes, in analogy to flipping pancakes. The conjecture is that the maximum count is approximated by n*log(n) when n goes to infinity.

    ## How to implement
    We ask that contributed programs not only give the correct result, but also **use the same algorithm** to calculate that result.

    Each program should:
    - Take a permutation of {1,...,n}, for example: {4,2,1,5,3}.
    - Take the first element, here 4, and reverse the order of the first 4 elements: {5,1,2,4,3}.
    - Repeat this until the first element is a 1, so flipping won't change anything more: {3,4,2,1,5}, {2,4,3,1,5}, {4,2,3,1,5}, {1,3,2,4,5}.
    - Count the number of flips, here 5.
    - Keep a checksum
        - checksum = checksum + (if permutation_index is even then flips_count else -flips_count)
        - checksum = checksum + (toggle_sign_-1_1 * flips_count)
    - Do this for all n! permutations, and record the maximum number of flips needed for any permutation.

    **diff** program output N = 7 with the expected [output file](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/fannkuchredux-output.txt) to check your program output has the correct format, before you [contribute your program.](https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/README.md)
    Use a larger command line argument (12) to check program performance.

    ## Example
    Thanks to Oleg Mazurov for insisting on a checksum and providing this helpful description of [the approach he took](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-java-1.html)
    - Common idea for parallel implementation is to divide all work (n! permutations) into chunks small enough to avoid load imbalance but large enough to keep overhead low. I set the number of chunks as a parameter (NCHUNKS = 150) from which I derive the size of a chunk (CHUNKSZ) and the actual number of chunks/tasks to be processed (NTASKS), which may be different from NCHUNKS because of rounding.
    - Task scheduling is trivial: threads will atomically get and increment the taskId variable to derive a range of permutation indices to work on:

    text
    task = taskId.getAndIncrement();
    idxMin = task * CHUNKSZ;
    idxMax = min( idxMin + CHUNKSZ, n! );
    - Maximum flip counts and partial checksums can be computed for chunks in arbitrary order and recombined to generate the required result at the final step (CHUNKSZ must be even for adding partial checksums to be associative - I didn't enforce it in my submission).
    - Now I need to go from a permutation index to the permutation itself.
    - The predefined order in which all permutations are to be generated can be described as follows: to generate n! permutations of n arbitrary numbers, rotate the numbers left (from higher position to lower) n times, so that each number appears in the n-th position, and for each rotation recursively generate (n-1)! permutations of the first n-1 numbers whatever they are.
    - To optimize the process I use an intermediate data structure, count[], which keeps count of how many rotations have been done at every level. Apparently, count is always 0, as there is only one element at that level, which can't be rotated; count = 0..1 for two elements, count = 0..2 for three elements, etc.
    - To generate next permutation I swap the first two elements and increase count. If count becomes greater than 1, I'm done with rotations at level 1 and need to "return" (as it would have been in the recursive implementation) to level 2. Now, I rotate 3 elements and increment count. If it becomes greater than 2, I'm done with level 2 and need to go to level 3, etc.
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-graalvmaot-1.html
    /*
     * The Computer Language Benchmarks Game
     * https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
     *
     * Contributed by Oleg Mazurov, June 2010
     *
     */

    import java.util.concurrent.atomic.AtomicInteger;

    public final class Program implements Runnable
    {
        private static final int NCHUNKS = 150;
        private static       int CHUNKSZ;
        private static       int NTASKS;
        private static int n;
        private static int[] Fact;
        private static int[] maxFlips;
        private static int[] chkSums;
        private static AtomicInteger taskId;

        int[] p, pp, count;

        void print()
        {
            for ( int i = 0; i < p.length; i++ ) {
                System.out.print( p[i] + 1 );
            }
            System.out.println();
        }

        void firstPermutation( int idx )
        {
            for ( int i=0; i<p.length; ++i ) {
               p[i] = i;
            }

            for ( int i=count.length-1; i>0; --i ) {
                int d = idx / Fact[i];
                count[i] = d;
                idx = idx % Fact[i];

                System.arraycopy( p, 0, pp, 0, i+1 );
                for ( int j=0; j<=i; ++j ) {
                    p[j] = j+d <= i ? pp[j+d] : pp[j+d-i-1];
                }
            }
        }

        boolean nextPermutation()
        {
            int first = p[1];
            p[1] = p[0];
            p[0] = first;

            int i=1;
            while ( ++count[i] > i ) {
                count[i++] = 0;
                int next = p[0] = p[1];
                for ( int j=1; j<i; ++j ) {
                    p[j] = p[j+1];
                }
                p[i] = first;
                first = next;
            }
            return true;
        }

        int countFlips()
        {
            int flips = 1;
        int first = p[0];
            if ( p[first] != 0 ) {
                System.arraycopy( p, 0, pp, 0, pp.length );
                do {
                     ++flips;
                     for ( int lo = 1, hi = first - 1; lo < hi; ++lo, --hi ) {
                        int t = pp[lo];
                        pp[lo] = pp[hi];
                        pp[hi] = t;
                     }
                     int t = pp[first];
                     pp[first] = first;
                     first = t;
                } while ( pp[first] != 0 );
            }
        return flips;
        }

        void runTask( int task )
        {
            int idxMin = task*CHUNKSZ;
            int idxMax = Math.min( Fact[n], idxMin+CHUNKSZ );

        firstPermutation( idxMin );

            int maxflips = 1;
            int chksum = 0;
            for ( int i=idxMin;; ) {

                if ( p[0] != 0 ) {
                    int flips = countFlips();
                    maxflips = Math.max( maxflips, flips );
            chksum += i%2 ==0 ? flips : -flips;
                }

            if ( ++i == idxMax ) {
                break;
            }

                nextPermutation();
            }
        maxFlips[task] = maxflips;
        chkSums[task]  = chksum;
        }

        public void run()
        {
            p     = new int[n];
            pp    = new int[n];
            count = new int[n];

            int task;
            while ( ( task = taskId.getAndIncrement() ) < NTASKS ) {
            runTask( task );
            }
        }

        static void printResult( int n, int res, int chk )
        {
            System.out.println( chk+"\nPfannkuchen("+n+") = "+res );
        }

        private static void run_benchmark(String[] args)
        {
            n = args.length > 0 ? Integer.parseInt( args[0] ) : 12;
            if ( n < 0 || n > 12 ) {         // 13! won't fit into int
                printResult( n, -1, -1 );
                return;
            }
            if ( n <= 1 ) {
                printResult( n, 0, 0 );
                return;
            }

            Fact = new int[n+1];
            Fact[0] = 1;
            for ( int i=1; i<Fact.length; ++i ) {
                Fact[i] = Fact[i-1] * i;
            }

            CHUNKSZ = (Fact[n] + NCHUNKS - 1) / NCHUNKS;
        NTASKS = (Fact[n] + CHUNKSZ - 1) / CHUNKSZ;
            maxFlips = new int[NTASKS];
            chkSums  = new int[NTASKS];
            taskId = new AtomicInteger(0);

            int nthreads = Runtime.getRuntime().availableProcessors();
            Thread[] threads = new Thread[nthreads];
            for ( int i=0; i<nthreads; ++i ) {
                threads[i] = new Thread( new Program() );
                threads[i].start();
            }
            for ( Thread t : threads ) {
                try {
                    t.join();
                }
                catch ( InterruptedException e ) {}
            }

            int res = 0;
            for ( int v : maxFlips ) {
                res = Math.max( res, v );
            }
            int chk = 0;
            for ( int v : chkSums ) {
                chk += v;
            }

            printResult( n, res, chk );
        }

        public static void main(String[] args) throws Exception {
            EnergySignal signal = new EnergySignal();
            while (true)
            {
                if (signal.startSignal() == 0) break;
                run_benchmark(args);
                signal.stopSignal();
            }
        }
    }
dependencies:
    - name: jdk24
      version: 24.0.1+9
---
args: [12]
expected_stdout: |
    3968050
    Pfannkuchen(12) = 65
