implementation: openjdk
name: spectral-norm
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/spectralnorm.html#spectralnorm
    Compute an approximation of the spectral norm ‖A‖₂ (largest singular value) of the infinite matrix
    - a_{ij} = 1 / ((i + j)(i + j + 1) / 2 + i + 1),    i, j ≥ 0.
    - Initialise a length-N vector u = (1, 1, …, 1)ᵀ.
    - Power-iteration loop – repeat N times:
    - v ← A·u (matrix–vector product on-the-fly)
    - u ← Aᵀ·v (transpose product)
    - Estimate the norm ‖A‖₂ ≈ √((u · v) / (v · v)).
    - Modular helpers to expose A(i,j), Av(u), Atv(v), and spectralNorm(N).
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/spectralnorm-javavm-3.html
    /*
    The Computer Language Benchmarks Game
    https://salsa.debian.org/benchmarksgame-team/benchmarksgame/

    contributed by Ziad Hatahet
    based on the Go entry by K P anonymous
    */

    import java.text.DecimalFormat;

    public class Program {
        private static final DecimalFormat formatter = new DecimalFormat("#.000000000");
        private static final int NCPU = Runtime.getRuntime().availableProcessors();

        public static void main(String[] args) throws Exception {
            EnergySignal signal = new EnergySignal();
            
            while (signal.startSignal() > 0) {
                run_benchmark(args);
                signal.stopSignal();
            }
        }

        private static void run_benchmark(String[] args) throws InterruptedException {
            final int n = args.length > 0 ? Integer.parseInt(args[0]) : 100;
            final var u = new double[n];
            for (int i = 0; i < n; i++)
                u[i] = 1.0;
            final var v = new double[n];
            for (int i = 0; i < 10; i++) {
                aTimesTransp(v, u);
                aTimesTransp(u, v);
            }

            double vBv = 0.0, vv = 0.0;
            for (int i = 0; i < n; i++) {
                final var vi = v[i];
                vBv += u[i] * vi;
                vv += vi * vi;
            }
            System.out.println(formatter.format(Math.sqrt(vBv / vv)));
        }

        private static void aTimesTransp(double[] v, double[] u) throws InterruptedException {
            final var x = new double[u.length];
            final var t = new Thread[NCPU];
            for (int i = 0; i < NCPU; i++) {
                t[i] = new Times(x, i * v.length / NCPU, (i + 1) * v.length / NCPU, u, false);
                t[i].start();
            }
            for (int i = 0; i < NCPU; i++)
                t[i].join();

            for (int i = 0; i < NCPU; i++) {
                t[i] = new Times(v, i * v.length / NCPU, (i + 1) * v.length / NCPU, x, true);
                t[i].start();
            }
            for (int i = 0; i < NCPU; i++)
                t[i].join();
        }

        private final static class Times extends Thread {
            private final double[] v, u;
            private final int ii, n;
            private final boolean transpose;

            public Times(double[] v, int ii, int n, double[] u, boolean transpose) {
                this.v = v;
                this.u = u;
                this.ii = ii;
                this.n = n;
                this.transpose = transpose;
            }

            @Override
            public void run() {
                final var ul = u.length;
                for (int i = ii; i < n; i++) {
                    double vi = 0.0;
                    for (int j = 0; j < ul; j++) {
                        if (transpose)
                            vi += u[j] / a(j, i);
                        else
                            vi += u[j] / a(i, j);
                    }
                    v[i] = vi;
                }
            }

            private static int a(int i, int j) {
                return (i + j) * (i + j + 1) / 2 + i + 1;
            }
        }
    }
dependencies:
    - name: jdk24
      version: 24.0.1+9
---
args: [5500]
expected_stdout: |
    1.274224153
