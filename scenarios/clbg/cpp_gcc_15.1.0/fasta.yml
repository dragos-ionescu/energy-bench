implementation: cpp
name: fasta
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/fasta.html#fasta
    ## Variance
    Please don't optimize the cumulative-probabilities lookup (for example, by using a scaling factor) or naïve LCG arithmetic - those programs will not be accepted.

    ## How to implement
    - Generate DNA sequences, by copying from a given sequence
    - Generate DNA sequences, by weighted random selection from 2 alphabets
    - Convert the expected probability of selecting each nucleotide into cumulative probabilities
    - Match a random number against those cumulative probabilities to select each nucleotide (use linear search or binary search)
    - Use this naïve linear congruential generator to calculate a random number each time a nucleotide needs to be selected (don't cache the random number sequence):
      - **IM** = 139968
      - **IA** = 3877
      - **IC** = 29573
      - **Seed** = 42
      - **Random (Max) Seed** = (Seed * IA + IC) modulo IM = Max * Seed / IM

    **diff** program output N = 1000 with this 10KB [output file](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/fasta-output.txt) to check your program output has the correct format, before you [contribute your program.](https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/README.md)
    Use a larger command line argument (25000000) to check program performance
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fasta-gpp-7.html
    /* The Computer Language Benchmarks Game
    [https://salsa.debian.org/benchmarksgame-team/benchmarksgame/](https://salsa.debian.org/benchmarksgame-team/benchmarksgame/)
    contributed by Sylvester Saguban
    inspired from C++ G++ #7 from Rafal Rusin and contributors
    - uses more features of C++17 and TS concept's 'auto' function parameters
    - more efficient multi-threading, which sadly is the reason why this
     this has more code than other implementations.
    - data structure from array of struct to struct of arrays for better
      cache locality and higher chance of vectorization
    compile with g++ 7.2
    with these flags -std=c++17 -march=native -O3 -msse -msse2 -msse3
    */

    #include <array>
    #include <cstdio>
    #include <thread>
    #include <algorithm>
    #include <mutex>
    #include <condition_variable>
    #include <atomic>
    #include <energy_signal.h>

    struct Config
    {
        static constexpr unsigned max_threads = 8;
        static constexpr unsigned min_threads = 1;
        static constexpr unsigned chars_per_line = 60;
        static constexpr unsigned max_proc = 4;
        static constexpr unsigned min_thread_work = (chars_per_line + 1) * 84;
        static constexpr unsigned max_thread_buff = (chars_per_line + 1) * 1024;

        static constexpr unsigned im = 139968, ia = 3877, ic = 29573;
        static constexpr float reciprocal = 1.0f / im;
        static inline FILE* output = stdout;
    };

    class ThreadMgr
    {
        struct Proc {
            std::atomic<bool>   once;
            std::mutex          mtx;
            unsigned            index, index_reset;
        };
        std::atomic<unsigned>       _out_sequence = 0;
        std::mutex                  _gen_mutex, _out_mutex;
        std::condition_variable     _cv;
        Proc                        _proc[ Config::max_proc ];
        unsigned                    _id_ctr = 0, _threads = 1, _proc_ctr = 0;

    public:
        struct Context {
            unsigned        index;
            union {
                alignas(16) std::array< int, Config::max_thread_buff > ibuff;
                alignas(16) std::array< char, Config::max_thread_buff > cbuff;
            };
        };

        void Reset() {
            _out_sequence = 0;
            _id_ctr = 0;
            _proc_ctr = 0;
            for( auto& i : _proc ) {
                i.once = true;
                i.index = 0;
                i.index_reset = 0;
            }
        }

        void SetThreadCount( unsigned count ) {
            _threads = std::clamp( count, Config::min_threads,
                                   Config::max_threads );
        }

        inline void SyncOutput( unsigned index, const auto& function ) {
            std::unique_lock lock(_out_mutex);
            _cv.wait( lock, [=]{ return index == _out_sequence; });
            function();
            ++_out_sequence;
            _cv.notify_all();
        }

        auto Make( const std::string_view& text, unsigned size, auto output ) {
            unsigned id = _id_ctr++;
            auto& proc = _proc[ _proc_ctr++ ];
            return [=, &proc]( ThreadMgr::Context& tdata ) {
                if( proc.once.exchange(false) )
                    this->SyncOutput( id, [&]{
                    std::fwrite( text.data(), 1, text.size(), Config::output );
                    output( size, tdata );
                });
            };
        }

        auto Make( const std::string_view& text, unsigned size,
                   auto generate, auto convert, auto output ) {
            unsigned work_count = std::clamp( size / _threads,
                                              Config::min_thread_work,
                                              Config::max_thread_buff );
            unsigned id = _id_ctr++;
            unsigned limit = id + (size / work_count) + (size % work_count != 0);
            _id_ctr = limit + 1;
            auto& proc = _proc[ _proc_ctr++ ];
            proc.index_reset = id + 1;
            return [=, &proc]( ThreadMgr::Context& tdata ) {
                if( proc.once.exchange(false) )
                    this->SyncOutput( id, [&] {
                    std::fwrite( text.data(), 1, text.size(), Config::output );
                });
                unsigned start_index = id + 1;
                while(true) {
                    unsigned cvsize;
                    {
                        std::scoped_lock lock(_gen_mutex);
                        {
                            std::scoped_lock lock(proc.mtx);
                            if( proc.index > limit )
                                break;
                            tdata.index = proc.index++;
                        }
                        cvsize = std::min( work_count, size -
                                           (((tdata.index - start_index)
                                             * work_count)) );
                        generate( cvsize, tdata );
                    }
                    unsigned char_count = convert( cvsize, start_index,
                                                   work_count, tdata );
                    this->SyncOutput( tdata.index, [&] {
                        if( tdata.index == limit &&
                                tdata.cbuff[char_count-1] != '\n' )
                            tdata.cbuff[char_count++] = '\n';
                        output( char_count, tdata );
                    });
                }
            };
        }

        void RunSequence( auto... f ){
            static_assert( sizeof...(f) <= Config::max_proc,
                           "function chain is too large, "
                           "increase Config::max_proc." );
            std::thread threads[ Config::max_threads ];
            _out_sequence = 0;
            _proc_ctr = 0;
            for( auto& i : _proc ) {
                i.once = true;
                i.index = i.index_reset;
            }
            for( unsigned i = 0; i < _threads; ++i )
                threads[i] = std::thread( [=]{
                    Context tdata = {0};
                    (f( tdata ), ...);
                });
            for( unsigned i = 0; i < _threads; ++i )
                threads[i].join();
        }
    } gdata;

    static unsigned random_seed;

    void initialize()
    {
        gdata.Reset();
        random_seed = 42;
    }

    void run_benchmark(int argc, char **argv)
    {
        static constexpr char alu[] =
            "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAG"
            "GTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC"
            "CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCC"
            "GGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTC"
            "CGTCTCAAAAA";
        static constexpr std::array< std::pair< float, char >, 15> iub = {{
             { 0.27f, 'a' }, { 0.12f, 'c' }, { 0.12f, 'g' }, { 0.27f, 't' },
             { 0.02f, 'B' }, { 0.02f, 'D' }, { 0.02f, 'H' }, { 0.02f, 'K' },
             { 0.02f, 'M' }, { 0.02f, 'N' }, { 0.02f, 'R' }, { 0.02f, 'S' },
             { 0.02f, 'V' }, { 0.02f, 'W' }, { 0.02f, 'Y' }
        }};
        static constexpr std::array< std::pair< float, char >, 4> homosapiens = {{
             { 0.3029549426680f, 'a' },
             { 0.1979883004921f, 'c' },
             { 0.1975473066391f, 'g' },
             { 0.3015094502008f, 't' }
        }};
        static auto make_commulative = []( const auto& p ) {
            struct Ret {
                alignas(16) std::array< float, p.size() >  real;
                alignas(16) std::array< char, p.size() >  ch;
            } ret{{p[0].first}, {p[0].second}};
            for(unsigned i = 1; i < p.size(); ++i ) {
                ret.real[i] = ret.real[i-1] + p[i].first;
                ret.ch[i] = p[i].second;
            }
            return ret;
        };
        auto get_random = []() {
            return (random_seed = (random_seed * Config::ia + Config::ic) % Config::im);
        };
        static auto convert = []( const auto& data, unsigned size,
                unsigned start_index, unsigned max_work,
                ThreadMgr::Context& tdata ) {
            auto iitr = tdata.ibuff.begin(), iend = iitr + size;
            auto citr = tdata.cbuff.begin();
            auto inner_loop = [&]( auto end ) {
                while( iitr != end ) {
                    auto f = *iitr++ * Config::reciprocal;
                    auto i = std::find_if( data.real.begin(),
                                           data.real.end(),
                                           [f]( auto t ){ return f <= t; });
                    *citr++ = data.ch[ i - data.real.begin() ];
                }
                *citr++ = '\n';
            };
            unsigned aligner_count = Config::chars_per_line -
                    ((max_work * (tdata.index - start_index))
                     % Config::chars_per_line);
            if( aligner_count > 0 )
                inner_loop( iitr + aligner_count );
            unsigned odd_count = (iend - iitr) % Config::chars_per_line;
            auto iend_blocks = iend - odd_count;
            while( iitr < iend_blocks )
                inner_loop( iitr + Config::chars_per_line );
            if( odd_count ) {
                inner_loop( iitr + odd_count );
                citr -= 1;
            }
            return citr - tdata.cbuff.begin();
        };
        auto generate = [&]( unsigned size, ThreadMgr::Context& tdata ) {
            for( auto i = tdata.ibuff.begin(), end = i + size; i != end; ++i )
                *i = get_random();
        };
        static auto output = []( unsigned size, ThreadMgr::Context& tdata ) {
            std::fwrite( tdata.cbuff.data(), 1, size, Config::output );
        };
        auto alu_out = [&]( unsigned size, ThreadMgr::Context& ) {
            static constexpr auto alu_data = [&] {
                constexpr unsigned char_count = (Config::chars_per_line + 1)
                        * (sizeof(alu) - 1);
                std::array< char, char_count > ret{};
                for(unsigned i = 0, j = 0; i < char_count; ++i, ++j) {
                    unsigned ul = std::min(i + Config::chars_per_line, char_count);
                    for(; i < ul; ++i )
                        ret[i] = alu[ (i - j) % (sizeof(alu) - 1)];
                    ret[i] = '\n';
                }
                return ret;
            }();
            constexpr unsigned char_count = Config::chars_per_line *
                    (sizeof(alu) - 1);
            for(; size >= char_count; size -= char_count )
                std::fwrite( alu_data.data(), 1, alu_data.size(), Config::output );
            std::fwrite( alu_data.data(), 1, size +
                         (size / Config::chars_per_line), Config::output );
            std::putc('\n', Config::output );
        };
        auto iub_convert = []( unsigned size, unsigned start_index,
                unsigned max_work, ThreadMgr::Context& tdata ) {
            static constexpr auto iub_data = make_commulative( iub );
            return convert( iub_data, size, start_index, max_work, tdata  );
        };
        auto homo_convert = []( unsigned size, unsigned start_index,
                unsigned max_work, ThreadMgr::Context& tdata ) {
            static constexpr auto hom_data = make_commulative( homosapiens );
            return convert( hom_data, size, start_index, max_work, tdata  );
        };
        gdata.SetThreadCount( std::thread::hardware_concurrency() );
        unsigned n = std::max( 1000, std::atoi( argv[1] ) );
        const auto alu_proc = gdata.Make( ">ONE Homo sapiens alu\n",
                                          n * 2, alu_out );
        const auto iub_proc = gdata.Make( ">TWO IUB ambiguity codes\n",
                                          n * 3, generate, iub_convert, output );
        const auto homo_proc = gdata.Make( ">THREE Homo sapiens frequency\n",
                                           n * 5, generate, homo_convert, output );
        gdata.RunSequence( alu_proc, iub_proc, homo_proc );
    }

    int main(int argc, char **argv)
    {
        while (1) {
            initialize();
            if (!start_signal()) break;
            run_benchmark(argc, argv);
            stop_signal();
        }
        return 0;
    }
dependencies:
    - name: gcc15
      version: 15.1.0
options:
    - -pipe
    - -O3
    - -march=native
    - -fomit-frame-pointer
    - -std=c++20
    - -lpthread
---
args: [1000]
expected_stdout: !!binary |
    Pk9ORSBIb21vIHNhcGllbnMgYWx1CkdHQ0NHR0dDR0NHR1RHR0NUQ0FDR0NDVEdUQUFUQ0NDQUdD
    QUNUVFRHR0dBR0dDQ0dBR0dDR0dHQ0dHQQpUQ0FDQ1RHQUdHVENBR0dBR1RUQ0dBR0FDQ0FHQ0NU
    R0dDQ0FBQ0FUR0dUR0FBQUNDQ0NHVENUQ1RBQ1QKQUFBQUFUQUNBQUFBQVRUQUdDQ0dHR0NHVEdH
    VEdHQ0dDR0NHQ0NUR1RBQVRDQ0NBR0NUQUNUQ0dHR0FHCkdDVEdBR0dDQUdHQUdBQVRDR0NUVEdB
    QUNDQ0dHR0FHR0NHR0FHR1RUR0NBR1RHQUdDQ0dBR0FUQ0dDRwpDQ0FDVEdDQUNUQ0NBR0NDVEdH
    R0NHQUNBR0FHQ0dBR0FDVENDR1RDVENBQUFBQUdHQ0NHR0dDR0NHR1QKR0dDVENBQ0dDQ1RHVEFB
    VENDQ0FHQ0FDVFRUR0dHQUdHQ0NHQUdHQ0dHR0NHR0FUQ0FDQ1RHQUdHVENBCkdHQUdUVENHQUdB
    Q0NBR0NDVEdHQ0NBQUNBVEdHVEdBQUFDQ0NDR1RDVENUQUNUQUFBQUFUQUNBQUFBQQpUVEFHQ0NH
    R0dDR1RHR1RHR0NHQ0dDR0NDVEdUQUFUQ0NDQUdDVEFDVENHR0dBR0dDVEdBR0dDQUdHQUcKQUFU
    Q0dDVFRHQUFDQ0NHR0dBR0dDR0dBR0dUVEdDQUdUR0FHQ0NHQUdBVENHQ0dDQ0FDVEdDQUNUQ0NB
    CkdDQ1RHR0dDR0FDQUdBR0NHQUdBQ1RDQ0dUQ1RDQUFBQUFHR0NDR0dHQ0dDR0dUR0dDVENBQ0dD
    Q1RHVApBQVRDQ0NBR0NBQ1RUVEdHR0FHR0NDR0FHR0NHR0dDR0dBVENBQ0NUR0FHR1RDQUdHQUdU
    VENHQUdBQ0MKQUdDQ1RHR0NDQUFDQVRHR1RHQUFBQ0NDQ0dUQ1RDVEFDVEFBQUFBVEFDQUFBQUFU
    VEFHQ0NHR0dDR1RHCkdUR0dDR0NHQ0dDQ1RHVEFBVENDQ0FHQ1RBQ1RDR0dHQUdHQ1RHQUdHQ0FH
    R0FHQUFUQ0dDVFRHQUFDQwpDR0dHQUdHQ0dHQUdHVFRHQ0FHVEdBR0NDR0FHQVRDR0NHQ0NBQ1RH
    Q0FDVENDQUdDQ1RHR0dDR0FDQUcKQUdDR0FHQUNUQ0NHVENUQ0FBQUFBR0dDQ0dHR0NHQ0dHVEdH
    Q1RDQUNHQ0NUR1RBQVRDQ0NBR0NBQ1RUClRHR0dBR0dDQ0dBR0dDR0dHQ0dHQVRDQUNDVEdBR0dU
    Q0FHR0FHVFRDR0FHQUNDQUdDQ1RHR0NDQUFDQQpUR0dUR0FBQUNDQ0NHVENUQ1RBQ1RBQUFBQVRB
    Q0FBQUFBVFRBR0NDR0dHQ0dUR0dUR0dDR0NHQ0dDQ1QKR1RBQVRDQ0NBR0NUQUNUQ0dHR0FHR0NU
    R0FHR0NBR0dBR0FBVENHQ1RUR0FBQ0NDR0dHQUdHQ0dHQUdHClRUR0NBR1RHQUdDQ0dBR0FUQ0dD
    R0NDQUNUR0NBQ1RDQ0FHQ0NUR0dHQ0dBQ0FHQUdDR0FHQUNUQ0NHVApDVENBQUFBQUdHQ0NHR0dD
    R0NHR1RHR0NUQ0FDR0NDVEdUQUFUQ0NDQUdDQUNUVFRHR0dBR0dDQ0dBR0cKQ0dHR0NHR0FUQ0FD
    Q1RHQUdHVENBR0dBR1RUQ0dBR0FDQ0FHQ0NUR0dDQ0FBQ0FUR0dUR0FBQUNDQ0NHClRDVENUQUNU
    QUFBQUFUQUNBQUFBQVRUQUdDQ0dHR0NHVEdHVEdHQ0dDR0NHQ0NUR1RBQVRDQ0NBR0NUQQpDVENH
    R0dBR0dDVEdBR0dDQUdHQUdBQVRDR0NUVEdBQUNDQ0dHR0FHR0NHR0FHR1RUR0NBR1RHQUdDQ0cK
    QUdBVENHQ0dDQ0FDVEdDQUNUQ0NBR0NDVEdHR0NHQUNBR0FHQ0dBR0FDVENDR1RDVENBQUFBQUdH
    Q0NHCkdHQ0dDR0dUR0dDVENBQ0dDQ1RHVEFBVENDQ0FHQ0FDVFRUR0dHQUdHQ0NHQUdHQ0dHR0NH
    R0FUQ0FDQwpUR0FHR1RDQUdHQUdUVENHQUdBQ0NBR0NDVEdHQ0NBQUNBVEdHVEdBQUFDQ0NDR1RD
    VENUQUNUQUFBQUEKVEFDQUFBQUFUVEFHQ0NHR0dDR1RHR1RHR0NHQ0dDR0NDVEdUQUFUQ0NDQUdD
    VEFDVENHR0dBR0dDVEdBCkdHQ0FHR0FHQUFUQ0dDVFRHQUFDQ0NHR0dBR0dDR0dBR0dUVEdDQUdU
    R0FHQ0NHQUdBVENHQ0dDQ0FDVApHQ0FDVENDQUdDQ1RHR0dDR0FDQUdBR0NHQUdBQ1RDQ0dUQ1RD
    QUFBQUFHR0NDR0dHQ0dDR0dUR0dDVEMKQUNHQ0NUR1RBQVRDQ0NBR0NBQ1RUVEdHR0FHR0NDR0FH
    R0NHR0dDR0dBVENBQ0NUR0FHR1RDQUdHQUdUClRDR0FHQUNDQUdDQ1RHR0NDQUFDQVRHR1RHQUFB
    Q0NDQ0dUQ1RDVEFDVEFBQUFBVEFDQUFBQUFUVEFHQwpDR0dHQ0dUR0dUR0dDR0NHQ0dDQ1RHVEFB
    VENDQ0FHQ1RBQ1RDR0dHQUdHQ1RHQUdHQ0FHR0FHQUFUQ0cKQ1RUR0FBQ0NDR0dHQUdHQ0dHQUdH
    VFRHQ0FHVEdBR0NDR0FHQVRDR0NHQ0NBQ1RHQ0FDVENDQUdDQ1RHCkdHQ0dBQ0FHQUdDR0FHQUNU
    Q0NHCj5UV08gSVVCIGFtYmlndWl0eSBjb2RlcwpjdHRCdGF0Y2F0YXRnY3RhS2dnTmNhdGFhYVNh
    dGd0YWFhRGNEUnRCZ2dEdGN0dHRhdGFhdHRjQmd0Y2cKdGFjdER0RGFnY2N0YXR0dFNWSHRIdHRL
    dGd0SE1hU2F0dGdXYUhLSHR0dHRhZ2FjYXRXYXRndFJnYWFhCk50YWN0TWNTTXRZdGNNZ1J0YWN0
    dGN0V0JhY2dhYWF0YXRhZ1NjRHR0dGdhYWdhY2FjYXRhZ3RWZ1lndApjYXR0SFd0TU1XY1N0Z3R0
    YWdnS3RTZ2FZYWFjY1dTdGNnQnR0Z2NnYU10dEJZYXRjV3RnYWNhWWNhZ2EKZ3RhQkR0UmFjdHR0
    dGNXYXRNdHREQmNhdFd0YXRjdHRhY3RhQmdhWXRjdHRndHR0dHR0dHRZYWFTY1lhCkhndGd0dE50
    U2F0Y010Y1ZhYWFTdGNjUmNjdERhYXRhYXRhU3RjWXRSRFNhTXREdHRndHRTYWd0UlJjYQp0dHRI
    YXRTdHRNdFdndGNndGF0U1NhZ2FjdFlhYWF0dGNhTXRXYXR0dGFTZ1l0dGFSZ0thUnRjY2FjdHQK
    dGF0dFJnZ2FNY0RhV2FXYWd0dHR0Z2FjYXRndHRjdGFjYWFhUmFhdGF0YWF0YWFNdHRjZ0RhY2dh
    U1N0CmFjYVN0WVJjdFZhTk10TWd0YWdnY0thdGN0dHR0YXR0YWFhYWFnVldhSEtZYWd0dHR0dGF0
    dHRhYWNjdAp0YWNndFZ0Y1ZhYXR0Vk1CY3R0YU10dHRhU3RnYWN0dGFnYXR0V1dhY1Z0Z1dZYWdX
    VlJjdERhdHRCWXQKZ3R0dGFhZ2FhZ2F0dGF0dGdhY1ZhdE1hYWNhdHRWY3RndEJTZ2FWdGdXV2dn
    YUtIYWF0S1djQlNjU1dhCmFjY1JWYWNhY2FhYWN0YWNjU2NhdHRSYXRhdEtWdGFjdGF0YXR0dEh0
    dGFhZ3R0dFNLdFJ0YWNhYWFndApSRHR0Y2FhYWFXZ2NhY2F0V2FEZ3RES2FjZ2FhY2FhdHRhY2FS
    TldhYXRIdHR0U3RndHRhdHRhYU10Z3QKdGdEY2d0TWdjYXRCdGdjdHRjZ2NnYURXZ2FnY3RnY2dh
    Z2dnZ1Z0YWFTY05hdHR0YWN0dGFhdGdhY2FnCmNjY2NjYWNhdFlTY2FNZ3RhZ2d0WWFOZ3R0Y3Rn
    YU1hYWNOYU1SYWFjYWFhY2FLY3RhY2F0YWdZV2N0Zwp0dFdhYWF0YWFhYXRhUmF0dGFnSGFjYWNh
    YWdjZ0thdGFjQnR0UnR0YWFndGF0dHRjY2dhdGN0SFNhYXQKYWN0Y050dE1hYWd0YXR0TXRnUnRn
    YU1nY2F0YWF0SGNNdGFCU2FSYXR0YWd0dGdhdEh0TXR0YWFLYWdnCll0YWFCYXRhU2FWYXRhY3RX
    dGF0YVZXZ0tndHRhYWFhY2FndGdjZ1JhdGF0YWNhdFZ0SFJ0VllhdGFTYQpLdFdhU3RWY05LSEt0
    dGFjdGF0Y2NjdGNhdGdXSGF0V2FSY3R0YWN0YWdnYXRjdGF0YUR0REhCdHRhdGEKYWFhSGd0YWNW
    dGFnYVl0dFlhS2NjdGF0dGN0dGN0dGFhdGFORGFhZ2dhYWFEWWdjZ2djdGFhV1NjdEJhCmFOdGdj
    dGdnTUJhS2N0YU1WS2FnQmFhY3RhV2FEYU1hY2NZVnROdGFIdFZXdEtnUnRjYWFOdFlhTmFjZwpn
    dHR0TmF0dGdWdHR0Y3RndEJhV2d0YWF0dGNhYWd0Y2FWV3RhY3ROZ2dhdHRjdHR0YVl0YWFhZ2Nj
    Z2MKdGN0dGFnSFZnZ2FZdGd0TmNEYVZhZ2N0Y3RjdEtnYWNndGF0YWdZY2N0UllIRHRnQmF0dERh
    YURnY2NLCnRjSGFhU3R0dE1jY3RhZ3RhdHRnY1JnV0JhVmF0SGFhYWF0YVl0Z3R0dGFnTURNUnRh
    YXRhYWdnYXRNdAp0dGN0V2d0TnRndGdhYWFhTWFhdGF0UnR0dE10RGdISHRndGNhdHR0dGNXYXR0
    UlNIY1ZhZ2FhZ3RhY2cKZ2d0YUtWYXR0S1lhZ2FjdE5hYXRndHR0Z0tNTWdZTnRjY2NnU0t0dGN0
    YVN0YXRhdE5WYXRhWUhndE5hCkJLUmdOYWNhYWN0Z2F0dHRjY3R0dGFOY2dhdHR0Y3RjdGF0YVNj
    YUh0YXRhUmFndGNSVnR0YWNEU0R0dAphUnRTYXRhY0hndFNLYWNZYWd0dE1IdFdhdGFnZ2F0Z2Fj
    dE50YXRTYU5jdGF0YVZ0dHRSTkt0Z1JhY2MKdHR0WXRhdGd0dGFjdHR0dHRjY3R0dGFhYWNhdGFj
    YUhhY3RNYWNhY2dndFdhdGFNdEJWYWNSYVNhYXRjCmNndGFCVnR0Y2NhZ2NjQmN0dGFSS3RndGdj
    Y3R0dHR0UnRndGNhZ2NSdHRLdGFhYWNLdGFhYXRjdGNhYwphYXR0Z2NhTnRTQmFhY2NnZ2d0dGF0
    dGFhQmNLYXREYWd0dGFjdGN0dGNhdHRWdHR0SGFhZ2djdEtLZ2EKdGFjYXRjQmdnU2NhZ3RWY2Fj
    YXR0dHRnYUhhRFNnSGF0Uk1hSFdnZ3RhdGF0UmdjY0R0dGNndGF0Y2dhCmFhY2FIdGFhZ3R0YVJh
    dGdhVmFjdHRhZ2F0dFZLdGFhWXR0YWFhdGNhTmF0Y2NSdHRSUmFNU2NOYWFhRApndHRWSFdndGNI
    YWFIZ2FjVmFXdGd0dFNjYWN0YWFnU2d0dGF0Y3R0YWdnZ0R0YWNjYWdXYXR0V3RSdGcKdHRIV0hh
    Y2dhdHRCdGdWY2FZYXRjZ2d0dGdhZ0tjV3RLS2NhVnRnYVlnV2N0Z1lnZ1ZjdGd0SGdhTmNWCnRh
    QnRXYWFZYXRjRFJhYVJ0U2N0Z2FIYVlSdHRhZ2F0TWF0Z2NhdHR0TmF0dGFEdHRhYXR0Z3R0Y3Rh
    YQpjY2N0Y2NjY3RhZ2FXQnR0dEh0QmNjdHRhZ2FWYWF0TWNCSGFnYVZjV2NhZ0JWdHRjQnRhWU1j
    Y2FnYXQKZ2FhYWFIY3RjdGFhY2d0dGFnTldSdGNnZ2F0dE5hdGNSYU5IdHRjYWd0S3R0dHRnV2F0
    V3R0Y1NhTmdnCmdhV3RhY3RLS01hYWNhdEthdGFjTmF0dGdjdFd0YXRjdGFWZ2FnY3RhdGd0UmFI
    dFljV2N0dGFnY2NhYQp0WXR0V3R0YVdTU3R0YUhjYWFhYWFnVmFjVmd0YVZhUk1nYXR0YVZjRGFj
    dHR0Y0hIZ2dIUnRnTmNjdHQKdFlhdGNhdEtnY3RjY3RjdGF0VmNhYWFhS2FhYWFndGF0YXRjdGdN
    dFd0YWFhYWNhU3R0dE10Y2dhY3R0CnRhU2F0Y2dEYXRhYWFjdGFhYWNhYWd0YWFWY3RhZ2dhU2Nj
    YWF0TVZ0YWFTS05WYXR0dHRnSGNjYXRjYQpjQlZjdGdjYVZhdFZ0dFJ0YWN0Z3RWY2FhdHRIZ3Rh
    YWF0dGFhYXR0dHRZdGF0YXR0YWFSU2dZdGdCYWcKYUhTQkRndGFnY2FjUkh0WWNCZ3RjYWN0dGFj
    YWN0YVljZ2N0V3RhdHRnU0h0U2F0Y2F0YWFhdGF0YUh0CmNndFlhYU1OZ0JhYXR0dGFSZ2FNYWF0
    YXR0dEJ0dHRhYWFISEthYXRjdGdhdFdhdFlhYWN0dE1jdGN0dAp0dFZjdGFnY3REYWFhZ3RhVmFL
    YUtSdGFhY0JndGF0Y2NhYWNjYWN0SEhhYWdhYWdhYWdnYU5hYWF0QlcKYXR0Y2NnU3RhTVNhTWF0
    QnR0Z2NhdGdSU2FjZ3R0VlZ0YWFETXRjU2dWYXRXY2FTYXRjdHR0dFZhdGFnCnR0YWN0dHRhY2dh
    dGNhY2NOdGFEVmdTUmNnVmNndGdhYWNnYU50YU5hdGF0YWd0SHRNZ3RIY010YWdhYQphdHRCZ3Rh
    dGFSYWFhYWNhWUtndFJjY1l0YXRnYWFndGFhdGFLZ3RhYU10dGdhYVJWYXRnY2FnYUtTdGMKdEhO
    YWFhdGN0QkJ0Y3R0YVlhQldIZ3RWdGdhY2FnY2FSY2F0YVdjdGNhQmNZYWNZZ2F0RGd0REhjY3Rh
    Cj5USFJFRSBIb21vIHNhcGllbnMgZnJlcXVlbmN5CmFhY2FjdHRjYWNjYWdndGF0Y2d0Z2FhZ2dj
    dGNhYWdhdHRhY2NjYWdhZ2FhY2N0dHRnY2FhdGF0YWFnYQphdGF0Z3RhdGdjYWdjYXR0YWNjY3Rh
    YWd0YWF0dGF0YXR0Y3R0dHR0Y3RnYWN0Y2FhYWd0Z2FjYWFnY2MKY3RhZ3RndGF0YXR0YWFhdGNn
    Z3RhdGF0dHRnZ2dhYWF0dGNjdGNhYWFjdGF0Y2N0YWF0Y2FnZ3RhZ2NjCmF0Z2FhYWd0Z2F0Y2Fh
    YWFhYWd0dGNndGFjdHRhdGFjY2F0YWNhdGdhYXR0Y3RnZ2NjYWFndGFhYWFhYQp0YWdhdHRnY2dj
    YWFhYXR0Y2d0YWNjdHRhYWd0Y3RjdGNnY2NhYWdhdGF0dGFnZ2F0Y2N0YXR0YWN0Y2EKdGF0Y2d0
    Z3R0dHR0Y3R0dGF0dGdjY2djY2F0Y2NjY2dnYWd0YXRjdGNhY2NjYXRjY3R0Y3RjdHRhYWFnCmdj
    Y3RhYXRhdHRhY2N0YXRnY2FhYXRhYWFjYXRhdGF0dGd0dGdhYWFhdHRnYWdhYWNjdGdhdGNndGdh
    dAp0Y3R0YXRndGd0YWNjYXRhdGd0YXRhZ3RhYXRjYWNnY2dhY3RhdGF0YWd0Z2N0dHRhZ3RhdGNn
    Y2NjZ3QKZ2dndGdhZ3RnYWF0YXR0Y3RnZ2djdGFnY2d0Z2FnYXRhZ3R0dGN0dGd0Y2N0YWF0YXR0
    dHR0Y2FnYXRjCmdhYXRhZ2N0dGN0YXR0dHR0Z3RndHR0YXR0Z2FjYXRhdGd0Y2dhYWFjdGNjdHRh
    Y3RjYWd0Z2FhYWd0YwphdGdhY2NhZ2F0Y2NhY2dhYWNhYXRjdHRjZ2dhYXRjYWd0Y3RjZ3R0dHRh
    Y2dnY2dnYWF0Y3R0Z2FndGMKdGFhY3R0YXRhdGNjY2d0Y2djdHRhY3R0dGN0YWFjYWNjY2N0dGF0
    Z3RhdHR0dHRhYWFhdHRhY2d0dHRhCnR0Y2dhYWNndGFjdHRnZ2NnZ2FhZ2NndHRhdHR0dHR0Z2Fh
    Z3RhYWd0dGFjYXR0Z2dnY2FnYWN0Y3R0ZwphY2F0dHR0Y2dhdGFjZ2FjdHR0Y3R0dGNhdGNjYXRj
    YWNhZ2dhY3RjZ3R0Y2d0YXR0Z2F0YXRjYWdhYWcKY3RjZ3RnYXRnYXR0YWd0dGd0Y3R0Y3R0dGFj
    Y2FhdGFjdHR0Z2FnZ2NjdGF0dGN0Z2NnYWFhdHR0dHRnCnR0Z2NjY3RnY2dhYWN0dGNhY2F0YWNj
    YWFnZ2FhY2FjY3RjZ2NhYWNhdGdjY3R0Y2F0YXRjY2F0Y2d0dApjYXR0Z3RhYXR0Y3R0YWNhY2Fh
    dGdhYXRjY3RhYWd0YWF0dGFjYXRjY2N0Z2NndGFhYWFnYXRnZ3RhZ2cKZ2djYWN0Z2FnZ2F0YXRh
    dHRhY2NhYWdjYXR0dGFndHRhdGdhZ3RhYXRjYWdjYWF0Z3R0dGN0dGd0YXR0CmFhZ3R0Y3RjdGFh
    YWF0YWd0dGFjYXRjZ3RhYXRndHRhdGN0Y2dnZ3R0Y2NnY2dhYXRhYWFjZ2FnYXRhZwphdHRjYXR0
    YXRhdGF0Z2djY2N0YWFnY2FhYWFhY2N0Y2N0Y2d0YXR0Y3RndHRnZ3RhYXR0YWdhYXRjYWMKYWNh
    YXRhY2dnZ3R0Z2FnYXRhdHRhYXR0YXR0dGd0YWd0YWNnYWFnYWdhdGF0YWFhYWFnYXRnYWFjYWF0
    CnRhY3RjYWFndGNhYWdhdGd0YXRhY2dnZ2F0dHRhdGFhdGFhYWFhdGNnZ2d0YWdhZ2F0Y3RnY3R0
    dGdjYQphdHRjYWdhY2d0Z2NjYWN0YWFhdGNndGFhdGF0Z3RjZ2NndHRhY2F0Y2FnYWFhZ2dndGFh
    Y3RhdHRhdHQKYWF0dGFhdGFhYWdnZ2N0dGFhdGNhY3RhY2F0YXR0YWdhdGN0dGF0Y2NnYXRhZ3Rj
    dHRhdGN0YXR0Y2d0CnRndGF0dHR0dGFhZ2NnZ3R0Y3RhYXR0Y2FndGNhdHRhdGF0Y2FndGdjdGNj
    Z2FndHRjdHR0YXR0YXR0Zwp0dHR0YWFnZ2F0Z2FjYWFhYXRnY2N0Y3R0Z3R0YXRhYWNnY3RnZ2dh
    Z2FhZ2NhZ2FjdGFhZ2FndGNnZ2EKZ2NhZ3R0Z2d0YWdhYXRnYWdnY3RnY2FhYWFnYWNnZ3RjdGNn
    YWNnYWF0Z2dhY2FnYWN0dHRhY3RhYWFjCmNhYXRnYWFhZ2FjYWdhYWd0YWdhZ2NhYWFndGN0Z2Fh
    Z3RnZ3RhdGNhZ2N0dGFhdHRhdGdhY2FhY2NjdAp0YWF0YWN0dGNjY3R0dGNnY2NnYWF0YWN0Z2dj
    Z3RnZ2FhYWdndHR0dGFhYWFndGNnYWFndGFndHRhZ2EKZ2djYXRjdGN0Y2djdGNhdGFhYXRhZ2d0
    YWdhY3RhY3RjZ2NhYXRjY2FhdGd0Z2FjdGF0Z3RhYXRhY3RnCmdnYWFjYXRjYWd0Y2NnY2dhdGdj
    YWdjZ3RndHR0YXRjYWFjY2d0Y2NjY2FjdGNnY2N0Z2dnZ2FnYWNhdApnYWdhY2NhY2NjY2NndGdn
    Z2dhdHRhdHRhZ3RjY2djYWd0YWF0Y2dhY3RjdHRnYWNhYXRjY3R0dHRjZ2EKdHRhdGd0Y2F0YWdj
    YWF0dHRhY2dhY2FndHRjYWdjZ2FhZ3RnYWN0YWN0Y2dnY2dhYWF0Z2d0YXR0YWN0CmFhYWdjYXR0
    Y2dhYWNjY2FjYXRnYWF0Z3RnYXR0Y3R0Z2djYWF0dHRjdGFhdGNjYWN0YWFhZ2N0dHR0YwpjZ3R0
    Z2FhdGN0Z2d0dGd0YWdhdGF0dHRhdGF0YWFndHRjYWN0YWF0dGFhZ2F0Y2FjZ2d0YWd0YXRhdHQK
    Z2F0YWd0Z2F0Z3RjdHR0Z2NhYWdhZ2d0dGdnY2NnYWdnYWF0dHRhY2dnYXR0Y3RjdGF0dGdhdGFj
    YWF0CnR0Z3RjdGdnY3R0YXRhYWN0Y3R0YWFnZ2N0Z2FhY2NhZ2djZ3R0dHR0YWdhY2dhY3R0Z2F0
    Y2FnY3RndAp0YWdhYXRnZ3R0dGdnYWN0Y2NjdGN0dHRjYXRndGNhZ3RhYWNhdHR0Y2FnY2NndHRh
    dHRndHRhY2dhdGEKdGdjdHRnYWFjYWF0YXR0Z2F0Y3RhY2NhY2FjYWNjY2F0YWd0YXRhdHR0dGF0
    YWdndGNhdGdjdGd0dGFjCmN0YWNnYWdjYXRnZ3RhdHRjY2FjdHRjY2NhdHRjYWF0Z2FndGF0dGNh
    YWNhdGNhY3RhZ2NjdGNhZ2FnYQp0Z2F0Z2FjY2NhY2N0Y3RhYXRhYWNndGNhY2d0dGdjZ2djY2F0
    Z3RnYWFhY2N0Z2FhY3R0Z2FndGFnYWMKZ2F0YXRjYWFnY2djdHR0YWFhdHRnY2F0YXRhYWNhdHR0
    Z2FnZ2d0YWFhZ2N0YWFnY2dnYXRnY3R0dGF0CmF0YWF0Y2FhdGFjdGNhYXRhYXRhYWdhdHR0Z2F0
    dGdjYXR0dHRhZ2FndHRhdGdhY2FjZ2FjYXRhZ3R0YwphY3RhYWNnYWd0dGFjdGF0dGNjY2FnYXRj
    dGFnYWN0Z2FhZ3RhY3RnYXRjZ2FnYWNnYXRjY3R0YWNndGMKZ2F0Z2F0Y2d0dGFndHRhdGNnYWN0
    dGFnZ3RjZ2dndGN0Y3RhZ2NnZ3RhdHRnZ3RhY3R0YWFjY2dnYWNhCmN0YXRhY3RhYXRhYWNjY2F0
    Z2F0Y2FhYWdjYXRhYWNhZ2FhdGFjYWdhY2dhdGFhdHR0Y2djY2FhY2F0YQp0YXRndGFjYWdhY2Nj
    Y2FhZ2NhdGdhZ2FhZ2N0Y2F0dGdhYWFnY3RhdGNhdHRnYWFndGNjY2djdGNhY2EKYXRndGd0Y3R0
    dHRjY2FnYWNnZ3R0dGFhY3RnZ3R0Y2NjZ2dnYWd0Y2N0Z2dhZ3R0dGNnYWN0dGFjYXRhCmFhdGdn
    YWFhY2FhdGd0YXR0dHRnY3RhYXR0dGF0Y3RhdGFnY2d0Y2F0dHRnZ2FjY2FhdGFjYWdhYXRhdAp0
    YXRndHRnY2N0YWd0YWF0Y2NhY3RhdGFhY2NjZ2NhYWd0Z2N0Z2F0YWdhYWFhdHR0dHRhZ2FjZ2F0
    dHQKYXRhYWF0Z2NjY2NhYWd0YXRjY2N0Y2NjZ3RnYWF0Y2N0Y2NndHRhdGFjdGFhdHRhZ3RhdHRj
    Z3R0Y2F0CmFjZ3RhdGFjY2djZ2NhdGF0YXRnYWFjYXR0dGdnY2dhdGFhZ2djZ2NndGdhYXR0Z3R0
    YWNndGdhY2FnYQpnYXRhZ2NhZ3R0dGN0dGd0Z2F0YXRnZ3R0YWFjYWdhY2d0YWNhdGdhYWdnZ2Fh
    YWN0dHRhdGF0Y3RhdGEKZ3RnYXRnY3R0Y2NndGFnYWFhdGFjY2djY2FjdGdndGN0Z2NjYWF0Z2F0
    Z2FhZ3RhdGd0YWdjdHR0YWdnCnR0dGd0YWN0YXRnYWdnY3R0dGNndHR0Z3R0dGdjYWdhZ3RhdGFh
    Y2FndHRnY2dhZ3RnYWFhYWFjY2dhYwpnYWF0dHRhdGFjdGFhdGFjZ2N0dHRjYWN0YXR0Z2djdGFj
    YWFhYXRhZ2dnYWFnYWd0dHRjYWF0Y2F0Z2EKZ2FnZ2dhZ3RhdGF0Z2dhdGdjdHR0Z3RhZ2N0YWFh
    Z2d0YWdhYWNndGF0Z3RhdGF0Z2N0Z2NjZ3R0Y2F0CnRjdHRnYWFhZ2F0YWNhdGFhZ2NnYXRhYWd0
    dGFjZ2FjYWF0dGF0YWFnY2FhY2F0Y2NjdGFjY3R0Y2d0YQphY2dhdHR0Y2FjdGd0dGFjdGdjZ2N0
    dGdhYWF0YWNhY3RhdGdnZ2djdGF0dGdnY2dnYWdhZ2FhZ2NhZ2EKdGNnY2djY2dhZ2NhdGF0YWNn
    YWdhY2N0YXRhYXRndHRnYXRnYXRhZ2FnYWFnZ2NndGN0Z2FhdHRnYXRhCmNhdGNnYWFndGFjYWN0
    dHRjdHR0Y2d0YWd0YXRjdGN0Y2d0Y2N0Y3R0dGN0YXRjdGNjZ2dhY2FjYWFnYQphdHRhYWd0dGF0
    YXRhdGF0YWdhZ3RjdHRhY2NhYXRjYXRndHRnYWF0Y2N0Z2F0dGN0Y2FnYWd0dGN0dHQKZ2djZ2dn
    Y2N0dGd0Z2F0Z2FjdGdhZ2FhYWNhYXRnY2FhdGF0dGdjdGNjYWFhdHR0Y2N0YWFnY2FhYXR0CmN0
    Y2dndHRhdGd0dGF0Z3R0YXRjYWdjYWFhZ2NndHRhY2d0dGF0Z3R0YXR0dGFhYXRjdGdnYWF0Z2Fj
    ZwpnYWdjZ2FhZ3R0Y3R0YXRndGNnZ3RndGdnZ2FhdGFhdHRjdHR0dGdhYWdhY2FnY2FjdGNjdHRh
    YWF0YWEKdGF0Y2djdGNjZ3RndHR0Z3RhdHR0YXRjZ2FhdGdnZ3RjdGd0YWFjY3R0Z2NhY2FhZ2Nh
    YWF0Y2dndGdnCnRndGF0YXRhdGNnZ2F0YWFjYWF0dGFhdGFjZ2F0Z3R0Y2F0YWd0Z2FjYWd0YXRh
    Y3RnYXRjZ2FndGNjdApjdGFhYWd0Y2FhdHRhY2N0Y2FjdHRhYWNhYXRjdGNhdHRnYXRndHRndGd0
    Y2F0dGNjY2dndGF0Y2djY2MKZ3RhZ3RhdGd0Z2N0Y3RnYXR0Z2FjY2dhZ3RndGdhYWNjYWFnZ2Fh
    Y2F0Y3RhY3RhYXRnY2N0dHRndHRhCmdndGFhZ2F0Y3RjdGN0Z2FhdHRjY3R0Y2d0Z2NjYWFjdHRh
    YWFhY2F0dGF0Y2FhYWF0dHRjdHRjdGFjdAp0Z2dhdHRhYWN0YWN0dHR0YWNnYWdjYXRnZ2NhYWF0
    dGNjY2N0Z3RnZ2FhZ2FjZ2d0dGNhdHRhdHRhdGMKZ2dhYWFjY3R0YXRhZ2FhYXR0Z2NndGd0dGdh
    Y3RnYWFhdHRhZ2F0dHR0dGF0dGd0YWFnYWd0dGdjYXRjCnR0dGdjZ2F0dGNjdGN0Z2d0Y3RhZ2N0
    dGNjYWF0Z2FhY2FndGNjdGNjY3R0Y3RhdHRjZ2FjYXRjZ2dndApjY3R0Y2d0YWNhdGd0Y3R0dGdj
    Z2F0Z3RhYXRhYXR0YWdndHRjZ2dhZ3RndGdnY2N0dGFhdGdnZ3RnY2EKYWN0YWdnYWF0YWNhYWNn
    Y2FhYXR0dGdjdGdhY2F0Z2F0YWdjYWFhdGNnZ3RhdGdjY2dnY2FjY2FhYWFjCmd0Z2N0Y2N0dGdj
    dHRhZ2N0dGd0Z2FhdGdhZ2FjdGNhZ3RhZ3R0YWFhdGFhYXRjY2F0YXRjdGdjYWF0YwpnYXR0Y2Nh
    Y2FnZ3RhdHRndGNjYWN0YXRjdHR0Z2FhY3RhY3RjdGFhZ2FnYXRhY2FhZ2N0dGFnY3RnYWcKYWNj
    Z2FnZ3RndGF0YXRnYWN0YWNnY3RnYXRhdGN0Z3RhYWdndGFjY2FhdGdjYWdnY2FhYWd0YXRnY2dh
    CmdhYWdjdGFhdGFjY2dnY3RndHR0Y2NhZ2N0dHRhdGFhZ2F0dGFhYWF0dHRnZ2N0Z3RjY3RnZ2Nn
    Z2NjdApjYWdhYXR0Z3R0Y3RhdGNndGFhdGNhZ3R0Z2d0dGNhdHRhYXR0YWdjdGFhZ3RhY2dhZ2d0
    YWNhYWN0dGEKdGN0Z3RjY2NhZ2FhY2FnY3RjY2FjYWFndHR0dHR0dGFjYWdjY2dhYWFjY2NjdGd0
    Z3RnYWF0Y3R0YWF0CmF0Y2NhYWdjZ2NndHRhdGN0Z2F0dGFnYWd0dHRhY2FhY3RjYWd0YXR0dHRh
    dGNhZ3RhY2d0dHR0Z3R0dApjY2FhY2F0dGFjY2NnZ3RhdGdhY2FhYWF0Z2FjZ2NjYWNndGd0Y2dh
    YXRhYXRnZ3RjdGdhY2NhYXRndGEKZ2dhYWd0Z2FhYWFnYXRhYWF0YXQK
