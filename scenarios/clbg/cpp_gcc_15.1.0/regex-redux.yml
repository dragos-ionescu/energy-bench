implementation: cpp
name: regex-redux
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/regexredux.html#regexredux
    ## Background
    [HN discussion](https://news.ycombinator.com/item?id=25627472) and ["regex engines on a curated set of tasks"](https://github.com/BurntSushi/rebar).

    ## Variance
    Some language implementations have regex built-in; some provide a regex library; some use a third-party regex library.
    The regex algorithm implemented is very likely to be different in different libraries.

    ## The work
    The work is to use the same simple regex patterns and actions to manipulate FASTA format data. Don't optimize away the work.

    ## How to implement
    We ask that contributed programs not only give the correct result, but also **use the same algorithm** to calculate that result.
    Each program should:
    - read all of a redirected [FASTA format](http://en.wikipedia.org/wiki/Fasta_format) file from stdin, and record the sequence length
    - use the same simple regex pattern match-replace to remove FASTA sequence descriptions and all linefeed characters, and record the sequence length
    - use the same simple regex patterns -
    agggtaaa|tttaccct
    [cgt]gggtaaa|tttaccc[acg]
    a[act]ggtaaa|tttacc[agt]t
    ag[act]gtaaa|tttac[agt]ct
    agg[act]taaa|ttta[agt]cct
    aggg[acg]aaa|ttt[cgt]ccct
    agggt[cgt]aa|tt[acg]accct
    agggta[cgt]a|t[acg]taccct
    agggtaa[cgt]|[acg]ttaccct
    - representing DNA 8-mers and their reverse complement (with a wildcard in one position), and (one pattern at a time) count matches in the redirected file
    - write the regex pattern and count
    - use the same magic regex patterns -
    tHa[Nt]
    aND|caN|Ha[DS]|WaS
    a[NSt]|BY
    <[^>]*>
    \|[^|][^|]*\|
    - to (one pattern at a time, in the same order) match-replace the pattern in the redirected file with -
    <4>
    <3>
    <2>
    |
    -
    - and record the sequence length
    - write the 3 recorded sequence lengths

    **diff** program output for this 10KB [input file](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/regexredux-input.txt) (generated with the [fasta program](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fasta.html N = 1000) with this [output file](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/regexredux-output.txt) to check your program output has the correct format, before you [contribute your program](https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/README.md).
    Generate a larger input file (using one of the [fasta programs](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fasta.html) with command line arguments: 5000000 > input5000000.txt) to check program performance.
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/regexredux-gpp-6.html
    // The Computer Language Benchmarks Game
    // [https://salsa.debian.org/benchmarksgame-team/benchmarksgame/](https://salsa.debian.org/benchmarksgame-team/benchmarksgame/)
    //
    // contributed by Markus Lenger
    //
    // This implementation of regex-redux uses the regular expression library PCRE2
    // PCRE2 allows to compile regular expressions into machine code at runtime
    // (JIT compile) which makes it extremely fast.
    //
    // See [https://www.pcre.org/current/doc/html/index.html](https://www.pcre.org/current/doc/html/index.html) for more info on PCRE2.
    // The code is heavily commented to enhance readability for people who don't
    // know C++. For those who do the comments might be annoying ;)

    #include <algorithm>
    #include <boost/noncopyable.hpp>
    #include <fstream>
    #include <future>
    #include <iostream>
    #include <iterator>
    #include <memory>
    #include <sstream>
    #include <vector>
    #define PCRE2_CODE_UNIT_WIDTH 8
    #include <pcre2.h>
    #include <energy_signal.h>

    // Cast std::string to PCRE2 buffer
    inline PCRE2_UCHAR8* pcre2_buffer_cast(std::string& str)
    {
        return reinterpret_cast<PCRE2_UCHAR8*>(str.data());
    }

    // Cast std::string to PCRE2 immutable string
    inline PCRE2_SPTR8 pcre2_string_cast(const std::string& str)
    {
        return reinterpret_cast<PCRE2_SPTR8>(str.c_str());
    }

    /*
     * This class wraps JIT-compiled PCRE2 regular expressions and data-structures
     * needed for matching the regular expressions against strings. The class is
     * derived from boost::noncopyable to prevent accidental copying.
     */
    class regex : private boost::noncopyable
    {
    public:
        inline explicit regex(const std::string& regex_str)
        {
            compile_regex(regex_str);
            allocate_match_data();
        }

        inline ~regex()
        {
            pcre2_code_free(_code);
            pcre2_match_data_free(_match_data);
            pcre2_match_context_free(_match_context);
            pcre2_jit_stack_free(_jit_stack);
        }

        // Count matches of this regex within subject
        inline std::size_t count_matches(const std::string& subject) const
        {
            // Definition of a functor for counting occurrences
            struct count_functor
            {
                std::size_t match_cnt = 0;
                /* This method (operator) will be called for every match in the
                 subject */
                inline void operator()(PCRE2_SPTR subject,
                    PCRE2_SIZE match_begin,
                    PCRE2_SIZE match_end)
                {
                    // We ignore these arguments
                    std::ignore = subject;
                    std::ignore = match_begin;
                    std::ignore = match_end;
                    // And just increase the match_cnt
                    match_cnt++;
                }
            };
            count_functor func;
            const PCRE2_SPTR subject_begin = pcre2_string_cast(subject);
            const PCRE2_SPTR subject_end = subject_begin + subject.size();
            // Here func.operator() is called for every match
            for_each_match(subject_begin, subject_end, func);
            return func.match_cnt;
        }

        /* Replace all matches of this regex between "subject_begin" and
          "subject_end" with "replacement" and store the result in the
          result_buffer */
        inline PCRE2_SIZE replace_all(const std::string& replacement,
            const PCRE2_SPTR8 subject_begin,
            const PCRE2_SPTR8 subject_end,
            PCRE2_UCHAR* const result_buffer_begin,
            PCRE2_UCHAR* const result_buffer_end) const
        {
            // Definition of a functor for replacing matches with strings
            struct replace_functor
            {
                PCRE2_UCHAR* _result_buffer_ptr;
                PCRE2_UCHAR* const _result_buffer_end;
                const std::string& _replacement;
                PCRE2_SIZE _replacement_size;

                inline replace_functor(PCRE2_UCHAR* const result_buffer_begin,
                    PCRE2_UCHAR* const result_buffer_end,
                    const std::string& replacement)
                    : _result_buffer_ptr(result_buffer_begin)
                    , _result_buffer_end(result_buffer_end)
                    , _replacement(replacement)
                    , _replacement_size(replacement.size())
                {
                }

                // This operator will be called for every match
                inline void operator()(const PCRE2_SPTR subject_ptr,
                    const PCRE2_SIZE match_begin,
                    const PCRE2_SIZE match_end)
                {
                    PCRE2_UCHAR* const next_result_buffer
                        = _result_buffer_ptr + match_begin + _replacement_size;
                    if (next_result_buffer > _result_buffer_end)
                    {
                        throw std::runtime_error("Result buffer too small");
                    }
                    // copy portions that did no match
                    std::copy(
                        subject_ptr, subject_ptr + match_begin, _result_buffer_ptr);
                    _result_buffer_ptr += match_begin;
                    // paste replacement string
                    std::copy(_replacement.begin(), _replacement.end(),
                        _result_buffer_ptr);
                    _result_buffer_ptr = next_result_buffer;
                }

                // Copy characters into the result buffer
                inline PCRE2_UCHAR* copy_into_result_buffer(
                    const PCRE2_SPTR begin, const PCRE2_SPTR end)
                {
                    // Copy remainder
                    if (begin >= end)
                        return _result_buffer_ptr;
                    const PCRE2_SIZE size = end - begin;
                    if (_result_buffer_ptr + size > _result_buffer_end)
                    {
                        throw std::runtime_error("Result buffer too small");
                    }
                    std::copy(begin, end, _result_buffer_ptr);
                    _result_buffer_ptr += size;
                    return _result_buffer_ptr;
                }
            };

            // Create an instance of the replace_functor
            replace_functor func(
                result_buffer_begin, result_buffer_end, replacement);
            /* Apply the func.operator() on every match. subject_ptr points to the
             * location just after the last match
             */
            PCRE2_SPTR subject_ptr
                = for_each_match(subject_begin, subject_end, func);
            // Copy remainder from subject to result
            PCRE2_UCHAR* result_buffer_ptr
                = func.copy_into_result_buffer(subject_ptr, subject_end);
            // Return the size of the result
            return result_buffer_ptr - result_buffer_begin;
        }

        inline std::string replace_all(
            const std::string& replacement, const std::string& subject) const
        {
            std::string result;
            result.resize(subject.size());
            PCRE2_UCHAR* buffer_begin = pcre2_buffer_cast(result);
            PCRE2_SPTR8 pcre2_subject = pcre2_string_cast(subject);
            auto result_size = replace_all(replacement, pcre2_subject,
                pcre2_subject + subject.size(), pcre2_buffer_cast(result),
                buffer_begin + result.size());

            result.resize(result_size);
            return result;
        }

    private:
        // Higher order function that allows application of functors to matches
        template <typename FUNCTOR>
        inline PCRE2_SPTR8 for_each_match(
            PCRE2_SPTR subject_begin, PCRE2_SPTR subject_end, FUNCTOR& action) const
        {
            PCRE2_SPTR subject_ptr = subject_begin;
            int status = 0;
            auto ovector = pcre2_get_ovector_pointer(_match_data);
            // offset of begin of match will always be stored in this array-element
            PCRE2_SIZE& begin_offset = ovector[0];
            // offset of end of match will always be stored in this array-element
            PCRE2_SIZE& end_offset = ovector[1];
            while (subject_ptr < subject_end
                && (status = pcre2_jit_match(_code, // JIT compiled regex
                        subject_ptr,
                        subject_end - subject_ptr, // Size of subject
                        0, // Offset into subject
                        0, // Flags
                        _match_data, // Match info is stored here
                        nullptr // Match context (none in our case)
                        ))
                    > 0)
            {
                // Call the functor
                action(subject_ptr, begin_offset, end_offset);
                subject_ptr += end_offset;
            }
            require_status_good(status);
            return subject_ptr;
        }

        inline void compile_regex(const std::string& regex_str)
        {
            PCRE2_SIZE error_offset;
            int error_number;
            // Parse and compile regular expression into PCRE2 representation
            _code = (pcre2_compile(pcre2_string_cast(regex_str),
                PCRE2_ZERO_TERMINATED, 0, &error_number, &error_offset, nullptr));
            if (!_code)
            {
                throw_pcre2_error(error_number);
            }
            // Now we transform the internal representation into machine code
            require_status_good(pcre2_jit_compile(_code, PCRE2_JIT_COMPLETE));
        }

        // Allocate PCRE2 objects for applying the regular expression
        // and storing the result
        inline void allocate_match_data()
        {
            _match_context = pcre2_match_context_create(nullptr);
            require_allocation_good(_match_context);

            _match_data = pcre2_match_data_create_from_pattern(_code, nullptr);
            require_allocation_good(_match_data);

            _jit_stack = pcre2_jit_stack_create(32 * 1024, 512 * 1024, nullptr);
            require_allocation_good(_jit_stack);

            pcre2_jit_stack_assign(_match_context, nullptr, _jit_stack);
        }

        // Throw runtime_error with error-message from PCRE2
        inline static void throw_pcre2_error(int status)
        {
            std::string msg;
            msg.resize(1024);
            pcre2_get_error_message(status, pcre2_buffer_cast(msg), msg.size());
            throw std::runtime_error(msg.c_str());
        }

        // Throw exception if pinter is nullptr
        inline static void require_allocation_good(void* ptr)
        {
            if (ptr == nullptr)
            {
                throw std::bad_alloc();
            }
        }

        // Throw an exception if a PCRE2 error occurred
        inline static void require_status_good(int status)
        {
            if (status < 0 && status != PCRE2_ERROR_NOMATCH)
            {
                throw_pcre2_error(status);
            }
        }

        pcre2_code* _code = nullptr;
        pcre2_match_data* _match_data = nullptr;
        pcre2_match_context* _match_context = nullptr;
        pcre2_jit_stack* _jit_stack = nullptr;
    };

    /// Patterns for counting
    const char* const count_regexes[] = { "agggtaaa|tttaccct",
        "[cgt]gggtaaa|tttaccc[acg]", "a[act]ggtaaa|tttacc[agt]t",
        "ag[act]gtaaa|tttac[agt]ct", "agg[act]taaa|ttta[agt]cct",
        "aggg[acg]aaa|ttt[cgt]ccct", "agggt[cgt]aa|tt[acg]accct",
        "agggta[cgt]a|t[acg]taccct", "agggtaa[cgt]|[acg]ttaccct" };

    using regex_replace_spec = std::pair<const char* const, const char* const>;

    /// Patterns + replacements for replacement operation
    const regex_replace_spec replace_specs[] = { { "tHa[Nt]", "<4>" },
        { "aND|caN|Ha[DS]|WaS", "<3>" }, { "a[NSt]|BY", "<2>" }, { "<[^>]*>", "|" },
        { "\\|[^|][^|]*\\|", "-" } };

    // Run asynchronous tasks in separate thread
    const auto launch_type = std::launch::async;

    // Read all data from input-stream and return as string
    inline std::string slurp(std::istream& in)
    {
        std::string input_data;
        size_t buffer_size = 1u << 14;
        input_data.resize(buffer_size);
        size_t space_left = buffer_size;
        while (in.good())
        {
            if (!space_left)
            {
                space_left = buffer_size;
                buffer_size *= 2;
                input_data.resize(buffer_size);
            }
            in.read(&input_data[buffer_size - space_left], space_left);
            space_left -= in.gcount();
        }
        input_data.resize(buffer_size - space_left);
        return input_data;
    }

    using counter_list = std::vector<size_t>;

    inline counter_list count_occurrences(const std::string& subject)
    {
        counter_list counters;
        std::vector<std::future<size_t>> tasks;
        for (const auto& regex_str : count_regexes)
        {
            tasks.emplace_back(
                // Launch task in separate thread
                std::async(launch_type, [&subject, &regex_str]() -> size_t {
                    regex re(regex_str);
                    return re.count_matches(subject);
                }));
        }
        counter_list results;
        // Get results from all asychronous tasks and store them in "results"
        std::transform(tasks.begin(), tasks.end(), std::back_inserter(results),
            [](auto& task) { return task.get(); });
        return results;
    }

    inline std::string replace_patterns(const std::string& subject)
    {
        PCRE2_SIZE current_size = subject.size();
        // A heuristic value new size = original_size * 1.1
        const PCRE2_SIZE buffer_size = current_size * 1.1;
        std::string source(subject);
        std::string sink;
        source.resize(buffer_size);
        sink.resize(buffer_size);
        for (auto replace_spec : replace_specs)
        {
            auto re = regex(replace_spec.first);
            PCRE2_SPTR8 pcre2_src = pcre2_string_cast(source);
            PCRE2_UCHAR* pcre2_sink = pcre2_buffer_cast(sink);
            current_size = re.replace_all(replace_spec.second, pcre2_src,
                pcre2_src + current_size, pcre2_sink, pcre2_sink + buffer_size);
            std::swap(source, sink);
        }
        source.resize(current_size);
        return source;
    }

    void initialize()
    {
        rewind(stdin);
        std::cin.clear();
    }

    void run_benchmark(int argc, char **argv)
    {
        try
        {
            std::string input = slurp(std::cin);
            auto clean_input_regex = regex(R"(>[^\n]*\n|\n)");
            // Remove newlines and comments
            std::string clean_input = clean_input_regex.replace_all("", input);

            // Launch counting of occurrences of patterns in separate thread
            auto count_task
                = std::async(launch_type, count_occurrences, clean_input);

            // Replace patterns with strings
            auto processed_input = replace_patterns(clean_input);
            // Get results from the thread that counted the occurrences of patterns
            auto counters = count_task.get();

            // Print occurrences to stdout
            size_t i = 0;
            for (auto counter : counters)
            {
                std::cout << count_regexes[i++] << " " << counter << "\n";
            }

            // Print string lengths to stdout
            std::cout << "\n"
                      << input.size() << "\n"
                      << clean_input.size() << "\n"
                      << processed_input.size() << std::endl;
        }
        catch (std::exception& e)
        {
            std::cerr << "Exception caught: " << e.what() << std::endl;
        }
    }

    int main(int argc, char **argv)
    {
        while (1) {
            initialize();
            if (!start_signal()) break;
            run_benchmark(argc, argv);
            stop_signal();
        }
        return 0;
    }
dependencies:
    - name: gcc15
      version: 15.1.0
    - name: pcre2
      version: 10.44
    - name: boost
      version: 1.87.0
options:
    - -pipe
    - -O3
    - -march=native
    - -fomit-frame-pointer
    - -lpthread
    - -lpcre2-8
    - -std=c++17
---
stdin: !!binary |
    Pk9ORSBIb21vIHNhcGllbnMgYWx1CkdHQ0NHR0dDR0NHR1RHR0NUQ0FDR0NDVEdUQUFUQ0NDQUdD
    QUNUVFRHR0dBR0dDQ0dBR0dDR0dHQ0dHQQpUQ0FDQ1RHQUdHVENBR0dBR1RUQ0dBR0FDQ0FHQ0NU
    R0dDQ0FBQ0FUR0dUR0FBQUNDQ0NHVENUQ1RBQ1QKQUFBQUFUQUNBQUFBQVRUQUdDQ0dHR0NHVEdH
    VEdHQ0dDR0NHQ0NUR1RBQVRDQ0NBR0NUQUNUQ0dHR0FHCkdDVEdBR0dDQUdHQUdBQVRDR0NUVEdB
    QUNDQ0dHR0FHR0NHR0FHR1RUR0NBR1RHQUdDQ0dBR0FUQ0dDRwpDQ0FDVEdDQUNUQ0NBR0NDVEdH
    R0NHQUNBR0FHQ0dBR0FDVENDR1RDVENBQUFBQUdHQ0NHR0dDR0NHR1QKR0dDVENBQ0dDQ1RHVEFB
    VENDQ0FHQ0FDVFRUR0dHQUdHQ0NHQUdHQ0dHR0NHR0FUQ0FDQ1RHQUdHVENBCkdHQUdUVENHQUdB
    Q0NBR0NDVEdHQ0NBQUNBVEdHVEdBQUFDQ0NDR1RDVENUQUNUQUFBQUFUQUNBQUFBQQpUVEFHQ0NH
    R0dDR1RHR1RHR0NHQ0dDR0NDVEdUQUFUQ0NDQUdDVEFDVENHR0dBR0dDVEdBR0dDQUdHQUcKQUFU
    Q0dDVFRHQUFDQ0NHR0dBR0dDR0dBR0dUVEdDQUdUR0FHQ0NHQUdBVENHQ0dDQ0FDVEdDQUNUQ0NB
    CkdDQ1RHR0dDR0FDQUdBR0NHQUdBQ1RDQ0dUQ1RDQUFBQUFHR0NDR0dHQ0dDR0dUR0dDVENBQ0dD
    Q1RHVApBQVRDQ0NBR0NBQ1RUVEdHR0FHR0NDR0FHR0NHR0dDR0dBVENBQ0NUR0FHR1RDQUdHQUdU
    VENHQUdBQ0MKQUdDQ1RHR0NDQUFDQVRHR1RHQUFBQ0NDQ0dUQ1RDVEFDVEFBQUFBVEFDQUFBQUFU
    VEFHQ0NHR0dDR1RHCkdUR0dDR0NHQ0dDQ1RHVEFBVENDQ0FHQ1RBQ1RDR0dHQUdHQ1RHQUdHQ0FH
    R0FHQUFUQ0dDVFRHQUFDQwpDR0dHQUdHQ0dHQUdHVFRHQ0FHVEdBR0NDR0FHQVRDR0NHQ0NBQ1RH
    Q0FDVENDQUdDQ1RHR0dDR0FDQUcKQUdDR0FHQUNUQ0NHVENUQ0FBQUFBR0dDQ0dHR0NHQ0dHVEdH
    Q1RDQUNHQ0NUR1RBQVRDQ0NBR0NBQ1RUClRHR0dBR0dDQ0dBR0dDR0dHQ0dHQVRDQUNDVEdBR0dU
    Q0FHR0FHVFRDR0FHQUNDQUdDQ1RHR0NDQUFDQQpUR0dUR0FBQUNDQ0NHVENUQ1RBQ1RBQUFBQVRB
    Q0FBQUFBVFRBR0NDR0dHQ0dUR0dUR0dDR0NHQ0dDQ1QKR1RBQVRDQ0NBR0NUQUNUQ0dHR0FHR0NU
    R0FHR0NBR0dBR0FBVENHQ1RUR0FBQ0NDR0dHQUdHQ0dHQUdHClRUR0NBR1RHQUdDQ0dBR0FUQ0dD
    R0NDQUNUR0NBQ1RDQ0FHQ0NUR0dHQ0dBQ0FHQUdDR0FHQUNUQ0NHVApDVENBQUFBQUdHQ0NHR0dD
    R0NHR1RHR0NUQ0FDR0NDVEdUQUFUQ0NDQUdDQUNUVFRHR0dBR0dDQ0dBR0cKQ0dHR0NHR0FUQ0FD
    Q1RHQUdHVENBR0dBR1RUQ0dBR0FDQ0FHQ0NUR0dDQ0FBQ0FUR0dUR0FBQUNDQ0NHClRDVENUQUNU
    QUFBQUFUQUNBQUFBQVRUQUdDQ0dHR0NHVEdHVEdHQ0dDR0NHQ0NUR1RBQVRDQ0NBR0NUQQpDVENH
    R0dBR0dDVEdBR0dDQUdHQUdBQVRDR0NUVEdBQUNDQ0dHR0FHR0NHR0FHR1RUR0NBR1RHQUdDQ0cK
    QUdBVENHQ0dDQ0FDVEdDQUNUQ0NBR0NDVEdHR0NHQUNBR0FHQ0dBR0FDVENDR1RDVENBQUFBQUdH
    Q0NHCkdHQ0dDR0dUR0dDVENBQ0dDQ1RHVEFBVENDQ0FHQ0FDVFRUR0dHQUdHQ0NHQUdHQ0dHR0NH
    R0FUQ0FDQwpUR0FHR1RDQUdHQUdUVENHQUdBQ0NBR0NDVEdHQ0NBQUNBVEdHVEdBQUFDQ0NDR1RD
    VENUQUNUQUFBQUEKVEFDQUFBQUFUVEFHQ0NHR0dDR1RHR1RHR0NHQ0dDR0NDVEdUQUFUQ0NDQUdD
    VEFDVENHR0dBR0dDVEdBCkdHQ0FHR0FHQUFUQ0dDVFRHQUFDQ0NHR0dBR0dDR0dBR0dUVEdDQUdU
    R0FHQ0NHQUdBVENHQ0dDQ0FDVApHQ0FDVENDQUdDQ1RHR0dDR0FDQUdBR0NHQUdBQ1RDQ0dUQ1RD
    QUFBQUFHR0NDR0dHQ0dDR0dUR0dDVEMKQUNHQ0NUR1RBQVRDQ0NBR0NBQ1RUVEdHR0FHR0NDR0FH
    R0NHR0dDR0dBVENBQ0NUR0FHR1RDQUdHQUdUClRDR0FHQUNDQUdDQ1RHR0NDQUFDQVRHR1RHQUFB
    Q0NDQ0dUQ1RDVEFDVEFBQUFBVEFDQUFBQUFUVEFHQwpDR0dHQ0dUR0dUR0dDR0NHQ0dDQ1RHVEFB
    VENDQ0FHQ1RBQ1RDR0dHQUdHQ1RHQUdHQ0FHR0FHQUFUQ0cKQ1RUR0FBQ0NDR0dHQUdHQ0dHQUdH
    VFRHQ0FHVEdBR0NDR0FHQVRDR0NHQ0NBQ1RHQ0FDVENDQUdDQ1RHCkdHQ0dBQ0FHQUdDR0FHQUNU
    Q0NHCj5UV08gSVVCIGFtYmlndWl0eSBjb2RlcwpjdHRCdGF0Y2F0YXRnY3RhS2dnTmNhdGFhYVNh
    dGd0YWFhRGNEUnRCZ2dEdGN0dHRhdGFhdHRjQmd0Y2cKdGFjdER0RGFnY2N0YXR0dFNWSHRIdHRL
    dGd0SE1hU2F0dGdXYUhLSHR0dHRhZ2FjYXRXYXRndFJnYWFhCk50YWN0TWNTTXRZdGNNZ1J0YWN0
    dGN0V0JhY2dhYWF0YXRhZ1NjRHR0dGdhYWdhY2FjYXRhZ3RWZ1lndApjYXR0SFd0TU1XY1N0Z3R0
    YWdnS3RTZ2FZYWFjY1dTdGNnQnR0Z2NnYU10dEJZYXRjV3RnYWNhWWNhZ2EKZ3RhQkR0UmFjdHR0
    dGNXYXRNdHREQmNhdFd0YXRjdHRhY3RhQmdhWXRjdHRndHR0dHR0dHRZYWFTY1lhCkhndGd0dE50
    U2F0Y010Y1ZhYWFTdGNjUmNjdERhYXRhYXRhU3RjWXRSRFNhTXREdHRndHRTYWd0UlJjYQp0dHRI
    YXRTdHRNdFdndGNndGF0U1NhZ2FjdFlhYWF0dGNhTXRXYXR0dGFTZ1l0dGFSZ0thUnRjY2FjdHQK
    dGF0dFJnZ2FNY0RhV2FXYWd0dHR0Z2FjYXRndHRjdGFjYWFhUmFhdGF0YWF0YWFNdHRjZ0RhY2dh
    U1N0CmFjYVN0WVJjdFZhTk10TWd0YWdnY0thdGN0dHR0YXR0YWFhYWFnVldhSEtZYWd0dHR0dGF0
    dHRhYWNjdAp0YWNndFZ0Y1ZhYXR0Vk1CY3R0YU10dHRhU3RnYWN0dGFnYXR0V1dhY1Z0Z1dZYWdX
    VlJjdERhdHRCWXQKZ3R0dGFhZ2FhZ2F0dGF0dGdhY1ZhdE1hYWNhdHRWY3RndEJTZ2FWdGdXV2dn
    YUtIYWF0S1djQlNjU1dhCmFjY1JWYWNhY2FhYWN0YWNjU2NhdHRSYXRhdEtWdGFjdGF0YXR0dEh0
    dGFhZ3R0dFNLdFJ0YWNhYWFndApSRHR0Y2FhYWFXZ2NhY2F0V2FEZ3RES2FjZ2FhY2FhdHRhY2FS
    TldhYXRIdHR0U3RndHRhdHRhYU10Z3QKdGdEY2d0TWdjYXRCdGdjdHRjZ2NnYURXZ2FnY3RnY2dh
    Z2dnZ1Z0YWFTY05hdHR0YWN0dGFhdGdhY2FnCmNjY2NjYWNhdFlTY2FNZ3RhZ2d0WWFOZ3R0Y3Rn
    YU1hYWNOYU1SYWFjYWFhY2FLY3RhY2F0YWdZV2N0Zwp0dFdhYWF0YWFhYXRhUmF0dGFnSGFjYWNh
    YWdjZ0thdGFjQnR0UnR0YWFndGF0dHRjY2dhdGN0SFNhYXQKYWN0Y050dE1hYWd0YXR0TXRnUnRn
    YU1nY2F0YWF0SGNNdGFCU2FSYXR0YWd0dGdhdEh0TXR0YWFLYWdnCll0YWFCYXRhU2FWYXRhY3RX
    dGF0YVZXZ0tndHRhYWFhY2FndGdjZ1JhdGF0YWNhdFZ0SFJ0VllhdGFTYQpLdFdhU3RWY05LSEt0
    dGFjdGF0Y2NjdGNhdGdXSGF0V2FSY3R0YWN0YWdnYXRjdGF0YUR0REhCdHRhdGEKYWFhSGd0YWNW
    dGFnYVl0dFlhS2NjdGF0dGN0dGN0dGFhdGFORGFhZ2dhYWFEWWdjZ2djdGFhV1NjdEJhCmFOdGdj
    dGdnTUJhS2N0YU1WS2FnQmFhY3RhV2FEYU1hY2NZVnROdGFIdFZXdEtnUnRjYWFOdFlhTmFjZwpn
    dHR0TmF0dGdWdHR0Y3RndEJhV2d0YWF0dGNhYWd0Y2FWV3RhY3ROZ2dhdHRjdHR0YVl0YWFhZ2Nj
    Z2MKdGN0dGFnSFZnZ2FZdGd0TmNEYVZhZ2N0Y3RjdEtnYWNndGF0YWdZY2N0UllIRHRnQmF0dERh
    YURnY2NLCnRjSGFhU3R0dE1jY3RhZ3RhdHRnY1JnV0JhVmF0SGFhYWF0YVl0Z3R0dGFnTURNUnRh
    YXRhYWdnYXRNdAp0dGN0V2d0TnRndGdhYWFhTWFhdGF0UnR0dE10RGdISHRndGNhdHR0dGNXYXR0
    UlNIY1ZhZ2FhZ3RhY2cKZ2d0YUtWYXR0S1lhZ2FjdE5hYXRndHR0Z0tNTWdZTnRjY2NnU0t0dGN0
    YVN0YXRhdE5WYXRhWUhndE5hCkJLUmdOYWNhYWN0Z2F0dHRjY3R0dGFOY2dhdHR0Y3RjdGF0YVNj
    YUh0YXRhUmFndGNSVnR0YWNEU0R0dAphUnRTYXRhY0hndFNLYWNZYWd0dE1IdFdhdGFnZ2F0Z2Fj
    dE50YXRTYU5jdGF0YVZ0dHRSTkt0Z1JhY2MKdHR0WXRhdGd0dGFjdHR0dHRjY3R0dGFhYWNhdGFj
    YUhhY3RNYWNhY2dndFdhdGFNdEJWYWNSYVNhYXRjCmNndGFCVnR0Y2NhZ2NjQmN0dGFSS3RndGdj
    Y3R0dHR0UnRndGNhZ2NSdHRLdGFhYWNLdGFhYXRjdGNhYwphYXR0Z2NhTnRTQmFhY2NnZ2d0dGF0
    dGFhQmNLYXREYWd0dGFjdGN0dGNhdHRWdHR0SGFhZ2djdEtLZ2EKdGFjYXRjQmdnU2NhZ3RWY2Fj
    YXR0dHRnYUhhRFNnSGF0Uk1hSFdnZ3RhdGF0UmdjY0R0dGNndGF0Y2dhCmFhY2FIdGFhZ3R0YVJh
    dGdhVmFjdHRhZ2F0dFZLdGFhWXR0YWFhdGNhTmF0Y2NSdHRSUmFNU2NOYWFhRApndHRWSFdndGNI
    YWFIZ2FjVmFXdGd0dFNjYWN0YWFnU2d0dGF0Y3R0YWdnZ0R0YWNjYWdXYXR0V3RSdGcKdHRIV0hh
    Y2dhdHRCdGdWY2FZYXRjZ2d0dGdhZ0tjV3RLS2NhVnRnYVlnV2N0Z1lnZ1ZjdGd0SGdhTmNWCnRh
    QnRXYWFZYXRjRFJhYVJ0U2N0Z2FIYVlSdHRhZ2F0TWF0Z2NhdHR0TmF0dGFEdHRhYXR0Z3R0Y3Rh
    YQpjY2N0Y2NjY3RhZ2FXQnR0dEh0QmNjdHRhZ2FWYWF0TWNCSGFnYVZjV2NhZ0JWdHRjQnRhWU1j
    Y2FnYXQKZ2FhYWFIY3RjdGFhY2d0dGFnTldSdGNnZ2F0dE5hdGNSYU5IdHRjYWd0S3R0dHRnV2F0
    V3R0Y1NhTmdnCmdhV3RhY3RLS01hYWNhdEthdGFjTmF0dGdjdFd0YXRjdGFWZ2FnY3RhdGd0UmFI
    dFljV2N0dGFnY2NhYQp0WXR0V3R0YVdTU3R0YUhjYWFhYWFnVmFjVmd0YVZhUk1nYXR0YVZjRGFj
    dHR0Y0hIZ2dIUnRnTmNjdHQKdFlhdGNhdEtnY3RjY3RjdGF0VmNhYWFhS2FhYWFndGF0YXRjdGdN
    dFd0YWFhYWNhU3R0dE10Y2dhY3R0CnRhU2F0Y2dEYXRhYWFjdGFhYWNhYWd0YWFWY3RhZ2dhU2Nj
    YWF0TVZ0YWFTS05WYXR0dHRnSGNjYXRjYQpjQlZjdGdjYVZhdFZ0dFJ0YWN0Z3RWY2FhdHRIZ3Rh
    YWF0dGFhYXR0dHRZdGF0YXR0YWFSU2dZdGdCYWcKYUhTQkRndGFnY2FjUkh0WWNCZ3RjYWN0dGFj
    YWN0YVljZ2N0V3RhdHRnU0h0U2F0Y2F0YWFhdGF0YUh0CmNndFlhYU1OZ0JhYXR0dGFSZ2FNYWF0
    YXR0dEJ0dHRhYWFISEthYXRjdGdhdFdhdFlhYWN0dE1jdGN0dAp0dFZjdGFnY3REYWFhZ3RhVmFL
    YUtSdGFhY0JndGF0Y2NhYWNjYWN0SEhhYWdhYWdhYWdnYU5hYWF0QlcKYXR0Y2NnU3RhTVNhTWF0
    QnR0Z2NhdGdSU2FjZ3R0VlZ0YWFETXRjU2dWYXRXY2FTYXRjdHR0dFZhdGFnCnR0YWN0dHRhY2dh
    dGNhY2NOdGFEVmdTUmNnVmNndGdhYWNnYU50YU5hdGF0YWd0SHRNZ3RIY010YWdhYQphdHRCZ3Rh
    dGFSYWFhYWNhWUtndFJjY1l0YXRnYWFndGFhdGFLZ3RhYU10dGdhYVJWYXRnY2FnYUtTdGMKdEhO
    YWFhdGN0QkJ0Y3R0YVlhQldIZ3RWdGdhY2FnY2FSY2F0YVdjdGNhQmNZYWNZZ2F0RGd0REhjY3Rh
    Cj5USFJFRSBIb21vIHNhcGllbnMgZnJlcXVlbmN5CmFhY2FjdHRjYWNjYWdndGF0Y2d0Z2FhZ2dj
    dGNhYWdhdHRhY2NjYWdhZ2FhY2N0dHRnY2FhdGF0YWFnYQphdGF0Z3RhdGdjYWdjYXR0YWNjY3Rh
    YWd0YWF0dGF0YXR0Y3R0dHR0Y3RnYWN0Y2FhYWd0Z2FjYWFnY2MKY3RhZ3RndGF0YXR0YWFhdGNn
    Z3RhdGF0dHRnZ2dhYWF0dGNjdGNhYWFjdGF0Y2N0YWF0Y2FnZ3RhZ2NjCmF0Z2FhYWd0Z2F0Y2Fh
    YWFhYWd0dGNndGFjdHRhdGFjY2F0YWNhdGdhYXR0Y3RnZ2NjYWFndGFhYWFhYQp0YWdhdHRnY2dj
    YWFhYXR0Y2d0YWNjdHRhYWd0Y3RjdGNnY2NhYWdhdGF0dGFnZ2F0Y2N0YXR0YWN0Y2EKdGF0Y2d0
    Z3R0dHR0Y3R0dGF0dGdjY2djY2F0Y2NjY2dnYWd0YXRjdGNhY2NjYXRjY3R0Y3RjdHRhYWFnCmdj
    Y3RhYXRhdHRhY2N0YXRnY2FhYXRhYWFjYXRhdGF0dGd0dGdhYWFhdHRnYWdhYWNjdGdhdGNndGdh
    dAp0Y3R0YXRndGd0YWNjYXRhdGd0YXRhZ3RhYXRjYWNnY2dhY3RhdGF0YWd0Z2N0dHRhZ3RhdGNn
    Y2NjZ3QKZ2dndGdhZ3RnYWF0YXR0Y3RnZ2djdGFnY2d0Z2FnYXRhZ3R0dGN0dGd0Y2N0YWF0YXR0
    dHR0Y2FnYXRjCmdhYXRhZ2N0dGN0YXR0dHR0Z3RndHR0YXR0Z2FjYXRhdGd0Y2dhYWFjdGNjdHRh
    Y3RjYWd0Z2FhYWd0YwphdGdhY2NhZ2F0Y2NhY2dhYWNhYXRjdHRjZ2dhYXRjYWd0Y3RjZ3R0dHRh
    Y2dnY2dnYWF0Y3R0Z2FndGMKdGFhY3R0YXRhdGNjY2d0Y2djdHRhY3R0dGN0YWFjYWNjY2N0dGF0
    Z3RhdHR0dHRhYWFhdHRhY2d0dHRhCnR0Y2dhYWNndGFjdHRnZ2NnZ2FhZ2NndHRhdHR0dHR0Z2Fh
    Z3RhYWd0dGFjYXR0Z2dnY2FnYWN0Y3R0ZwphY2F0dHR0Y2dhdGFjZ2FjdHR0Y3R0dGNhdGNjYXRj
    YWNhZ2dhY3RjZ3R0Y2d0YXR0Z2F0YXRjYWdhYWcKY3RjZ3RnYXRnYXR0YWd0dGd0Y3R0Y3R0dGFj
    Y2FhdGFjdHR0Z2FnZ2NjdGF0dGN0Z2NnYWFhdHR0dHRnCnR0Z2NjY3RnY2dhYWN0dGNhY2F0YWNj
    YWFnZ2FhY2FjY3RjZ2NhYWNhdGdjY3R0Y2F0YXRjY2F0Y2d0dApjYXR0Z3RhYXR0Y3R0YWNhY2Fh
    dGdhYXRjY3RhYWd0YWF0dGFjYXRjY2N0Z2NndGFhYWFnYXRnZ3RhZ2cKZ2djYWN0Z2FnZ2F0YXRh
    dHRhY2NhYWdjYXR0dGFndHRhdGdhZ3RhYXRjYWdjYWF0Z3R0dGN0dGd0YXR0CmFhZ3R0Y3RjdGFh
    YWF0YWd0dGFjYXRjZ3RhYXRndHRhdGN0Y2dnZ3R0Y2NnY2dhYXRhYWFjZ2FnYXRhZwphdHRjYXR0
    YXRhdGF0Z2djY2N0YWFnY2FhYWFhY2N0Y2N0Y2d0YXR0Y3RndHRnZ3RhYXR0YWdhYXRjYWMKYWNh
    YXRhY2dnZ3R0Z2FnYXRhdHRhYXR0YXR0dGd0YWd0YWNnYWFnYWdhdGF0YWFhYWFnYXRnYWFjYWF0
    CnRhY3RjYWFndGNhYWdhdGd0YXRhY2dnZ2F0dHRhdGFhdGFhYWFhdGNnZ2d0YWdhZ2F0Y3RnY3R0
    dGdjYQphdHRjYWdhY2d0Z2NjYWN0YWFhdGNndGFhdGF0Z3RjZ2NndHRhY2F0Y2FnYWFhZ2dndGFh
    Y3RhdHRhdHQKYWF0dGFhdGFhYWdnZ2N0dGFhdGNhY3RhY2F0YXR0YWdhdGN0dGF0Y2NnYXRhZ3Rj
    dHRhdGN0YXR0Y2d0CnRndGF0dHR0dGFhZ2NnZ3R0Y3RhYXR0Y2FndGNhdHRhdGF0Y2FndGdjdGNj
    Z2FndHRjdHR0YXR0YXR0Zwp0dHR0YWFnZ2F0Z2FjYWFhYXRnY2N0Y3R0Z3R0YXRhYWNnY3RnZ2dh
    Z2FhZ2NhZ2FjdGFhZ2FndGNnZ2EKZ2NhZ3R0Z2d0YWdhYXRnYWdnY3RnY2FhYWFnYWNnZ3RjdGNn
    YWNnYWF0Z2dhY2FnYWN0dHRhY3RhYWFjCmNhYXRnYWFhZ2FjYWdhYWd0YWdhZ2NhYWFndGN0Z2Fh
    Z3RnZ3RhdGNhZ2N0dGFhdHRhdGdhY2FhY2NjdAp0YWF0YWN0dGNjY3R0dGNnY2NnYWF0YWN0Z2dj
    Z3RnZ2FhYWdndHR0dGFhYWFndGNnYWFndGFndHRhZ2EKZ2djYXRjdGN0Y2djdGNhdGFhYXRhZ2d0
    YWdhY3RhY3RjZ2NhYXRjY2FhdGd0Z2FjdGF0Z3RhYXRhY3RnCmdnYWFjYXRjYWd0Y2NnY2dhdGdj
    YWdjZ3RndHR0YXRjYWFjY2d0Y2NjY2FjdGNnY2N0Z2dnZ2FnYWNhdApnYWdhY2NhY2NjY2NndGdn
    Z2dhdHRhdHRhZ3RjY2djYWd0YWF0Y2dhY3RjdHRnYWNhYXRjY3R0dHRjZ2EKdHRhdGd0Y2F0YWdj
    YWF0dHRhY2dhY2FndHRjYWdjZ2FhZ3RnYWN0YWN0Y2dnY2dhYWF0Z2d0YXR0YWN0CmFhYWdjYXR0
    Y2dhYWNjY2FjYXRnYWF0Z3RnYXR0Y3R0Z2djYWF0dHRjdGFhdGNjYWN0YWFhZ2N0dHR0YwpjZ3R0
    Z2FhdGN0Z2d0dGd0YWdhdGF0dHRhdGF0YWFndHRjYWN0YWF0dGFhZ2F0Y2FjZ2d0YWd0YXRhdHQK
    Z2F0YWd0Z2F0Z3RjdHR0Z2NhYWdhZ2d0dGdnY2NnYWdnYWF0dHRhY2dnYXR0Y3RjdGF0dGdhdGFj
    YWF0CnR0Z3RjdGdnY3R0YXRhYWN0Y3R0YWFnZ2N0Z2FhY2NhZ2djZ3R0dHR0YWdhY2dhY3R0Z2F0
    Y2FnY3RndAp0YWdhYXRnZ3R0dGdnYWN0Y2NjdGN0dHRjYXRndGNhZ3RhYWNhdHR0Y2FnY2NndHRh
    dHRndHRhY2dhdGEKdGdjdHRnYWFjYWF0YXR0Z2F0Y3RhY2NhY2FjYWNjY2F0YWd0YXRhdHR0dGF0
    YWdndGNhdGdjdGd0dGFjCmN0YWNnYWdjYXRnZ3RhdHRjY2FjdHRjY2NhdHRjYWF0Z2FndGF0dGNh
    YWNhdGNhY3RhZ2NjdGNhZ2FnYQp0Z2F0Z2FjY2NhY2N0Y3RhYXRhYWNndGNhY2d0dGdjZ2djY2F0
    Z3RnYWFhY2N0Z2FhY3R0Z2FndGFnYWMKZ2F0YXRjYWFnY2djdHR0YWFhdHRnY2F0YXRhYWNhdHR0
    Z2FnZ2d0YWFhZ2N0YWFnY2dnYXRnY3R0dGF0CmF0YWF0Y2FhdGFjdGNhYXRhYXRhYWdhdHR0Z2F0
    dGdjYXR0dHRhZ2FndHRhdGdhY2FjZ2FjYXRhZ3R0YwphY3RhYWNnYWd0dGFjdGF0dGNjY2FnYXRj
    dGFnYWN0Z2FhZ3RhY3RnYXRjZ2FnYWNnYXRjY3R0YWNndGMKZ2F0Z2F0Y2d0dGFndHRhdGNnYWN0
    dGFnZ3RjZ2dndGN0Y3RhZ2NnZ3RhdHRnZ3RhY3R0YWFjY2dnYWNhCmN0YXRhY3RhYXRhYWNjY2F0
    Z2F0Y2FhYWdjYXRhYWNhZ2FhdGFjYWdhY2dhdGFhdHR0Y2djY2FhY2F0YQp0YXRndGFjYWdhY2Nj
    Y2FhZ2NhdGdhZ2FhZ2N0Y2F0dGdhYWFnY3RhdGNhdHRnYWFndGNjY2djdGNhY2EKYXRndGd0Y3R0
    dHRjY2FnYWNnZ3R0dGFhY3RnZ3R0Y2NjZ2dnYWd0Y2N0Z2dhZ3R0dGNnYWN0dGFjYXRhCmFhdGdn
    YWFhY2FhdGd0YXR0dHRnY3RhYXR0dGF0Y3RhdGFnY2d0Y2F0dHRnZ2FjY2FhdGFjYWdhYXRhdAp0
    YXRndHRnY2N0YWd0YWF0Y2NhY3RhdGFhY2NjZ2NhYWd0Z2N0Z2F0YWdhYWFhdHR0dHRhZ2FjZ2F0
    dHQKYXRhYWF0Z2NjY2NhYWd0YXRjY2N0Y2NjZ3RnYWF0Y2N0Y2NndHRhdGFjdGFhdHRhZ3RhdHRj
    Z3R0Y2F0CmFjZ3RhdGFjY2djZ2NhdGF0YXRnYWFjYXR0dGdnY2dhdGFhZ2djZ2NndGdhYXR0Z3R0
    YWNndGdhY2FnYQpnYXRhZ2NhZ3R0dGN0dGd0Z2F0YXRnZ3R0YWFjYWdhY2d0YWNhdGdhYWdnZ2Fh
    YWN0dHRhdGF0Y3RhdGEKZ3RnYXRnY3R0Y2NndGFnYWFhdGFjY2djY2FjdGdndGN0Z2NjYWF0Z2F0
    Z2FhZ3RhdGd0YWdjdHR0YWdnCnR0dGd0YWN0YXRnYWdnY3R0dGNndHR0Z3R0dGdjYWdhZ3RhdGFh
    Y2FndHRnY2dhZ3RnYWFhYWFjY2dhYwpnYWF0dHRhdGFjdGFhdGFjZ2N0dHRjYWN0YXR0Z2djdGFj
    YWFhYXRhZ2dnYWFnYWd0dHRjYWF0Y2F0Z2EKZ2FnZ2dhZ3RhdGF0Z2dhdGdjdHR0Z3RhZ2N0YWFh
    Z2d0YWdhYWNndGF0Z3RhdGF0Z2N0Z2NjZ3R0Y2F0CnRjdHRnYWFhZ2F0YWNhdGFhZ2NnYXRhYWd0
    dGFjZ2FjYWF0dGF0YWFnY2FhY2F0Y2NjdGFjY3R0Y2d0YQphY2dhdHR0Y2FjdGd0dGFjdGdjZ2N0
    dGdhYWF0YWNhY3RhdGdnZ2djdGF0dGdnY2dnYWdhZ2FhZ2NhZ2EKdGNnY2djY2dhZ2NhdGF0YWNn
    YWdhY2N0YXRhYXRndHRnYXRnYXRhZ2FnYWFnZ2NndGN0Z2FhdHRnYXRhCmNhdGNnYWFndGFjYWN0
    dHRjdHR0Y2d0YWd0YXRjdGN0Y2d0Y2N0Y3R0dGN0YXRjdGNjZ2dhY2FjYWFnYQphdHRhYWd0dGF0
    YXRhdGF0YWdhZ3RjdHRhY2NhYXRjYXRndHRnYWF0Y2N0Z2F0dGN0Y2FnYWd0dGN0dHQKZ2djZ2dn
    Y2N0dGd0Z2F0Z2FjdGdhZ2FhYWNhYXRnY2FhdGF0dGdjdGNjYWFhdHR0Y2N0YWFnY2FhYXR0CmN0
    Y2dndHRhdGd0dGF0Z3R0YXRjYWdjYWFhZ2NndHRhY2d0dGF0Z3R0YXR0dGFhYXRjdGdnYWF0Z2Fj
    ZwpnYWdjZ2FhZ3R0Y3R0YXRndGNnZ3RndGdnZ2FhdGFhdHRjdHR0dGdhYWdhY2FnY2FjdGNjdHRh
    YWF0YWEKdGF0Y2djdGNjZ3RndHR0Z3RhdHR0YXRjZ2FhdGdnZ3RjdGd0YWFjY3R0Z2NhY2FhZ2Nh
    YWF0Y2dndGdnCnRndGF0YXRhdGNnZ2F0YWFjYWF0dGFhdGFjZ2F0Z3R0Y2F0YWd0Z2FjYWd0YXRh
    Y3RnYXRjZ2FndGNjdApjdGFhYWd0Y2FhdHRhY2N0Y2FjdHRhYWNhYXRjdGNhdHRnYXRndHRndGd0
    Y2F0dGNjY2dndGF0Y2djY2MKZ3RhZ3RhdGd0Z2N0Y3RnYXR0Z2FjY2dhZ3RndGdhYWNjYWFnZ2Fh
    Y2F0Y3RhY3RhYXRnY2N0dHRndHRhCmdndGFhZ2F0Y3RjdGN0Z2FhdHRjY3R0Y2d0Z2NjYWFjdHRh
    YWFhY2F0dGF0Y2FhYWF0dHRjdHRjdGFjdAp0Z2dhdHRhYWN0YWN0dHR0YWNnYWdjYXRnZ2NhYWF0
    dGNjY2N0Z3RnZ2FhZ2FjZ2d0dGNhdHRhdHRhdGMKZ2dhYWFjY3R0YXRhZ2FhYXR0Z2NndGd0dGdh
    Y3RnYWFhdHRhZ2F0dHR0dGF0dGd0YWFnYWd0dGdjYXRjCnR0dGdjZ2F0dGNjdGN0Z2d0Y3RhZ2N0
    dGNjYWF0Z2FhY2FndGNjdGNjY3R0Y3RhdHRjZ2FjYXRjZ2dndApjY3R0Y2d0YWNhdGd0Y3R0dGdj
    Z2F0Z3RhYXRhYXR0YWdndHRjZ2dhZ3RndGdnY2N0dGFhdGdnZ3RnY2EKYWN0YWdnYWF0YWNhYWNn
    Y2FhYXR0dGdjdGdhY2F0Z2F0YWdjYWFhdGNnZ3RhdGdjY2dnY2FjY2FhYWFjCmd0Z2N0Y2N0dGdj
    dHRhZ2N0dGd0Z2FhdGdhZ2FjdGNhZ3RhZ3R0YWFhdGFhYXRjY2F0YXRjdGdjYWF0YwpnYXR0Y2Nh
    Y2FnZ3RhdHRndGNjYWN0YXRjdHR0Z2FhY3RhY3RjdGFhZ2FnYXRhY2FhZ2N0dGFnY3RnYWcKYWNj
    Z2FnZ3RndGF0YXRnYWN0YWNnY3RnYXRhdGN0Z3RhYWdndGFjY2FhdGdjYWdnY2FhYWd0YXRnY2dh
    CmdhYWdjdGFhdGFjY2dnY3RndHR0Y2NhZ2N0dHRhdGFhZ2F0dGFhYWF0dHRnZ2N0Z3RjY3RnZ2Nn
    Z2NjdApjYWdhYXR0Z3R0Y3RhdGNndGFhdGNhZ3R0Z2d0dGNhdHRhYXR0YWdjdGFhZ3RhY2dhZ2d0
    YWNhYWN0dGEKdGN0Z3RjY2NhZ2FhY2FnY3RjY2FjYWFndHR0dHR0dGFjYWdjY2dhYWFjY2NjdGd0
    Z3RnYWF0Y3R0YWF0CmF0Y2NhYWdjZ2NndHRhdGN0Z2F0dGFnYWd0dHRhY2FhY3RjYWd0YXR0dHRh
    dGNhZ3RhY2d0dHR0Z3R0dApjY2FhY2F0dGFjY2NnZ3RhdGdhY2FhYWF0Z2FjZ2NjYWNndGd0Y2dh
    YXRhYXRnZ3RjdGdhY2NhYXRndGEKZ2dhYWd0Z2FhYWFnYXRhYWF0YXQK
expected_stdout: |
    agggtaaa|tttaccct 1
    [cgt]gggtaaa|tttaccc[acg] 0
    a[act]ggtaaa|tttacc[agt]t 0
    ag[act]gtaaa|tttac[agt]ct 0
    agg[act]taaa|ttta[agt]cct 1
    aggg[acg]aaa|ttt[cgt]ccct 0
    agggt[cgt]aa|tt[acg]accct 0
    agggta[cgt]a|t[acg]taccct 0
    agggtaa[cgt]|[acg]ttaccct 2

    10245
    10000
    5262
