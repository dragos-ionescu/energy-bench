implementation: rust
name: fannkuch-redux
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/fannkuchredux.html#fannkuchredux
    The fannkuch benchmark is defined by programs in [pdf]Performing Lisp Analysis of the FANNKUCH Benchmark, Kenneth R. Anderson and Duane Rettig. FANNKUCH is an abbreviation for the German word Pfannkuchen, or pancakes, in analogy to flipping pancakes. The conjecture is that the maximum count is approximated by n*log(n) when n goes to infinity.
    We ask that contributed programs not only give the correct result, but also **use the same algorithm** to calculate that result.
    Each program should:
        - Take a permutation of {1,...,n}, for example: {4,2,1,5,3}.
        - Take the first element, here 4, and reverse the order of the first 4 elements: {5,1,2,4,3}.
        - Repeat this until the first element is a 1, so flipping won't change anything more: {3,4,2,1,5}, {2,4,3,1,5}, {4,2,3,1,5}, {1,3,2,4,5}.
        - Count the number of flips, here 5.
        - Keep a checksum
            - checksum = checksum + (if permutation_index is even then flips_count else -flips_count)
            - checksum = checksum + (toggle_sign_-1_1 * flips_count)
        - Do this for all n! permutations, and record the maximum number of flips needed for any permutation.
        - common idea for parallel implementation is to divide all work (n! permutations) into chunks small enough to avoid load imbalance but large enough to keep overhead low. I set the number of chunks as a parameter (NCHUNKS = 150) from which I derive the size of a chunk (CHUNKSZ) and the actual number of chunks/tasks to be processed (NTASKS), which may be different from NCHUNKS because of rounding.
        - Task scheduling is trivial: threads will atomically get and increment the taskId variable to derive a range of permutation indices to work on:
            task = taskId.getAndIncrement();
            idxMin = task * CHUNKSZ;
            idxMax = min( idxMin + CHUNKSZ, n! );
        - Maximum flip counts and partial checksums can be computed for chunks in arbitrary order and recombined to generate the required result at the final step (CHUNKSZ must be even for adding partial checksums to be associative).
        - Now I need to go from a permutation index to the permutation itself.
        - The predefined order in which all permutations are to be generated can be described as follows: to generate n! permutations of n arbitrary numbers, rotate the numbers left (from higher position to lower) n times, so that each number appears in the n-th position, and for each rotation recursively generate (n-1)! permutations of the first n-1 numbers whatever they are.
        - To optimize the process I use an intermediate data structure, count[], which keeps count of how many rotations have been done at every level. Apparently, count[0] is always 0, as there is only one element at that level, which can't be rotated; count[1] = 0..1 for two elements, count[2] = 0..2 for three elements, etc.
        - To generate next permutation I swap the first two elements and increase count[1]. If count[1] becomes greater than 1, I'm done with rotations at level 1 and need to "return" (as it would have been in the recursive implementation) to level 2. Now, I rotate 3 elements and increment count[2]. If it becomes greater than 2, I'm done with level 2 and need to go to level 3, etc.
        - It should be clear now how to generate a permutation and corresponding count[] array from an arbitrary index. Basically, count[k] = ( index % (k+1)! ) / k! is the number of rotations we need to perform on elements 0..k. Doing it in the descending order from n-1 to 1 gives us both the count[] array and the permutation.
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-rust-4.html
    // The Computer Language Benchmarks Game
    // https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
    //
    // contributed by the Rust Project Developers
    // contributed by TeXitoi
    // contributed by Cristi Cobzarenco

    extern crate rayon;

    use std::{cmp, mem};
    use rayon::prelude::*;

    // This value controls the preferred maximum number of  blocks the workload is
    // broken up into. The actual value may be one higher (if the number of
    // permutations doesn't divide exactly by this value) or might be set to 1 if
    // the number of permutations is lower than this value.
    const NUM_BLOCKS: u32 = 24;

    fn fannkuch(n: i32) -> (i32, i32) {
        // Precompute a table a factorials to reuse all over the place.
        let mut factorials = [1; 16];
        for i in 1..n as usize + 1 {
            factorials[i] = factorials[i - 1] * i as u32;
        }
        let perm_max = factorials[n as usize];

        // Compute the number of blocks and their size. If n! is less than
        // NUM_BLOCKS then use a single block (perform the work serially for small
        // values of n). If n! doesn't divide exactly by NUM_BLOCKS, then add one
        // extra block to compute the remainder.
        let (num_blocks, block_size) = if perm_max < NUM_BLOCKS {
            (1, perm_max)
        } else {
            (NUM_BLOCKS + if perm_max % NUM_BLOCKS == 0 { 0 } else { 1 },
             perm_max / NUM_BLOCKS)
        };

        // Compute the `checksum` and `maxflips` for each block in parallel.
        (0..num_blocks).into_par_iter().map(|i_block| {
            let initial = i_block * block_size;
            let mut count = [0i32; 16];
            let mut temp = [0i32; 16];
            let mut current = [0i32; 16];

            // Initialise `count` and the current permutation (`current`)
            for (i, value) in current.iter_mut().enumerate() {
                *value = i as i32;
            }

            let mut permutation_index = initial as i32;
            for i in (1..n as usize).rev() {
                let factorial = factorials[i] as i32;
                let d = permutation_index / factorial;
                permutation_index %= factorial;
                count[i] = d;

                temp.copy_from_slice(&current);
                let d = d as usize;
                for j in 0..i + 1 {
                    current[j] = if j + d <= i {
                        temp[j + d]
                    } else {
                        temp[j + d - i - 1]
                    };
                }
            }

            // Iterate over each permutation in the block.
            let last_permutation_in_block = cmp::min(initial + block_size,
                                                     perm_max) - 1;
            let mut permutation_index = initial;
            let (mut checksum, mut maxflips) = (0, 0);
            loop {
                // If the first value in the current permutation is not 1 (0) then
                // we will need to do at least one flip for `current`.
                if current[0] > 0 {
                    // Copy the current permutation to work on it.
                    temp.copy_from_slice(&current);

                    // Flip `temp` (the copy of the current permutation) until its
                    // first element is 1 (0).
                    let mut flip_count = 1;
                    let mut first_value = current[0] as usize;
                    while temp[first_value] != 0 {
                        let new_first_value = mem::replace(&mut temp[first_value],
                                                           first_value as i32);
                        // If the first value is greater than 3 (2), then we are
                        // flipping a series of four or more values so we will need
                        // to flip additional elements in the middle of `temp`.
                        if first_value > 2 {
                            temp[1..first_value].reverse();
                        }

                        // Update `first_value` to the value we saved earlier and
                        // record a flip in `flip_count`.
                        first_value = new_first_value as usize;
                        flip_count += 1;
                    }

                    // Update the `checksum` and `maxflips` of this block.
                    checksum += if permutation_index % 2 == 0 {
                        flip_count
                    } else {
                        -flip_count
                    };
                    maxflips = cmp::max(maxflips, flip_count);
                }

                // If this was the last permutation in the block, we're done: return
                // the `checksum` and `maxflips` values which get reduced across
                // blocks in parallel by `rayon`.
                if permutation_index >= last_permutation_in_block {
                    return (checksum, maxflips);
                }
                permutation_index += 1;

                // Generate the next permutation.
                let mut first_value = current[1];
                current[1] = current[0];
                current[0] = first_value;
                let mut i = 1;
                while count[i] >= i as i32 {
                    count[i] = 0;
                    i += 1;
                    let new_first_value = current[1];
                    current[0] = new_first_value;
                    for j in 1..i {
                        current[j] = current[j + 1];
                    }
                    current[i] = mem::replace(&mut first_value, new_first_value);
                }
                count[i] += 1;
            }
        }).reduce(|| (0, 0),
                  |(cs1, mf1), (cs2, mf2)| (cs1 + cs2, cmp::max(mf1, mf2)))
    }

    fn main() {
        let n = std::env::args().nth(1)
            .and_then(|n| n.parse().ok())
            .unwrap_or(7);

        let (checksum, maxflips) = fannkuch(n);
        println!("{}\nPfannkuchen({}) = {}", checksum, n, maxflips);
    }
dependencies:
    - name: cargo
      version: 1.86.0
    - name: rustc
      version: 1.86.0
options:
    - --release
    - --config profile.release.codegen-units=1
packages:
    - name: rayon
      version: 1.10.0
---
args: [12]
expected_stdout: |
    3968050
    Pfannkuchen(12) = 65
