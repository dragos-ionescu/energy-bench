implementation: ruby
name: fannkuch-redux
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/fannkuchredux.html#fannkuchredux
    The fannkuch benchmark is defined by programs in [pdf]Performing Lisp Analysis of the FANNKUCH Benchmark, Kenneth R. Anderson and Duane Rettig. FANNKUCH is an abbreviation for the German word Pfannkuchen, or pancakes, in analogy to flipping pancakes. The conjecture is that the maximum count is approximated by n*log(n) when n goes to infinity.
    We ask that contributed programs not only give the correct result, but also **use the same algorithm** to calculate that result.
    Each program should:
        - Take a permutation of {1,...,n}, for example: {4,2,1,5,3}.
        - Take the first element, here 4, and reverse the order of the first 4 elements: {5,1,2,4,3}.
        - Repeat this until the first element is a 1, so flipping won't change anything more: {3,4,2,1,5}, {2,4,3,1,5}, {4,2,3,1,5}, {1,3,2,4,5}.
        - Count the number of flips, here 5.
        - Keep a checksum
            - checksum = checksum + (if permutation_index is even then flips_count else -flips_count)
            - checksum = checksum + (toggle_sign_-1_1 * flips_count)
        - Do this for all n! permutations, and record the maximum number of flips needed for any permutation.
        - common idea for parallel implementation is to divide all work (n! permutations) into chunks small enough to avoid load imbalance but large enough to keep overhead low. I set the number of chunks as a parameter (NCHUNKS = 150) from which I derive the size of a chunk (CHUNKSZ) and the actual number of chunks/tasks to be processed (NTASKS), which may be different from NCHUNKS because of rounding.
        - Task scheduling is trivial: threads will atomically get and increment the taskId variable to derive a range of permutation indices to work on:
            task = taskId.getAndIncrement();
            idxMin = task * CHUNKSZ;
            idxMax = min( idxMin + CHUNKSZ, n! );
        - Maximum flip counts and partial checksums can be computed for chunks in arbitrary order and recombined to generate the required result at the final step (CHUNKSZ must be even for adding partial checksums to be associative).
        - Now I need to go from a permutation index to the permutation itself.
        - The predefined order in which all permutations are to be generated can be described as follows: to generate n! permutations of n arbitrary numbers, rotate the numbers left (from higher position to lower) n times, so that each number appears in the n-th position, and for each rotation recursively generate (n-1)! permutations of the first n-1 numbers whatever they are.
        - To optimize the process I use an intermediate data structure, count[], which keeps count of how many rotations have been done at every level. Apparently, count[0] is always 0, as there is only one element at that level, which can't be rotated; count[1] = 0..1 for two elements, count[2] = 0..2 for three elements, etc.
        - To generate next permutation I swap the first two elements and increase count[1]. If count[1] becomes greater than 1, I'm done with rotations at level 1 and need to "return" (as it would have been in the recursive implementation) to level 2. Now, I rotate 3 elements and increment count[2]. If it becomes greater than 2, I'm done with level 2 and need to go to level 3, etc.
        - It should be clear now how to generate a permutation and corresponding count[] array from an arbitrary index. Basically, count[k] = ( index % (k+1)! ) / k! is the number of rotations we need to perform on elements 0..k. Doing it in the descending order from n-1 to 1 gives us both the count[] array and the permutation.
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-ruby-2.html
    # The Computer Language Benchmarks Game
    # https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
    # Contributed by Wesley Moxam
    # Modified by Sokolov Yura aka funny_falcon
    # Parallelised by Scott Leggett
    # Thread.exclusive deprecated

    require 'thread'

    module MiniParallel
        class Worker
            def initialize(read, write)
                @read, @write = read, write
            end

            def close_pipes
                @read.close
                @write.close
            end

            def work(index)
                Marshal.dump(index, @write)
                Marshal.load(@read)
            end
        end

        def self.map(array, &block)
            work_in_processes(
                array,
                [array.size, core_count].min,
                &block
            )
        end

        def self.core_count
            @@core_count ||= IO.read("/proc/cpuinfo").scan(/^processor/).size
        end

        private

        def self.work_in_processes(array, count, &block)
            index = -1
            results, threads = [], []
            mx = Mutex.new

            workers = create_workers(array, count, &block)

            workers.each do |worker|
                threads << Thread.new do
                    loop do
                        mx.synchronize do index += 1 end
                        break if index >= array.size
                        results[index] = worker.work(index)
                    end
                    worker.close_pipes
                end
            end

            threads.each(&:join)
            Process.waitall

            results
        end

        def self.create_workers(array, count, &block)
            workers = []
            count.times do
                workers << create_worker(array, workers, &block)
            end
            workers
        end

        def self.create_worker(array, started_workers, &block)
            child_read, parent_write = IO.pipe
            parent_read, child_write = IO.pipe

            Process.fork do
                started_workers.each(&:close_pipes)

                parent_write.close
                parent_read.close

                process_incoming_jobs(child_read, child_write, array, &block)

                child_read.close
                child_write.close
            end

            child_read.close
            child_write.close

            Worker.new(parent_read, parent_write)
        end

        def self.process_incoming_jobs(read, write, array, &block)
            until read.eof?
                index = Marshal.load(read)
                Marshal.dump(block.call(array[index]), write)
            end
        end
    end

    class Fannkuch

        def initialize(n, start, max_perms)
            @n = n
            @p = (0..n).to_a
            @s = @p.dup
            @q = @p.dup
            @sign = 1
            @sum = @maxflips = 0
            @max_perms = max_perms
            @perm_count = -start
            start.times{permute}
        end

        def flip
            loop do
                if @perm_count == @max_perms
                    return [@sum, @maxflips]
                end
                if (q1 = @p[1]) != 1
                    @q[0..-1] = @p
                    flips = 1
                    until (qq = @q[q1]) == 1
                        @q[q1] = q1
                        if q1 >= 4
                            i, j = 2, q1 - 1
                            while i < j
                                @q[i], @q[j] = @q[j], @q[i]
                                i += 1
                                j -= 1
                            end
                        end
                        q1 = qq
                        flips += 1
                    end
                    @sum += @sign * flips
                    @maxflips = flips if flips > @maxflips # New maximum?
                end
                permute
            end
        end

        def permute
            @perm_count += 1

            if @sign == 1
                # Rotate 1<-2.

                @p[1], @p[2] = @p[2], @p[1]
                @sign = -1
            else
                # Rotate 1<-2 and 1<-2<-3.

                @p[2], @p[3] = @p[3], @p[2]
                @sign = 1
                i = 3
                while i <= @n && @s[i] == 1
                    @s[i] = i
                    # Rotate 1<-...<-i+1.

                    t = @p.delete_at(1)
                    i += 1
                    @p.insert(i, t)
                end
                @s[i] -= 1  if i <= @n
            end
        end
    end

    abort "Usage: #{__FILE__} n\n(n > 6)" if (n = ARGV[0].to_i) < 6

    core_count = MiniParallel.core_count
    chunk_size = (1..n).reduce(:*) / core_count

    sum, flips =
        if core_count > 1
            # adjust job sizes to even out workload
            weights = if core_count > 1
                          weights = []
                          (core_count/2).times do |i|
                              weights << i * 0.1 + 0.05
                          end
                          weights = weights.reverse + weights.map{|i|-i}
                      else
                          [0]
                      end

            # Generate start position for each chunk
            chunks = core_count.times.zip(weights).map do |count, weight|
                [count * chunk_size +
                 (count > 0 ? (weights[0,count].reduce(:+) * chunk_size).round : 0),
                 chunk_size + (weight * chunk_size).round]
            end

            chunk_results =
                if (RUBY_PLATFORM == 'java')
                    chunk_collector = []
                    threads = []
                    chunks.each.with_index do |(start,weighted_size),i|
                        threads << Thread.new do
                            chunk_collector[i] = Fannkuch.new(n,start,weighted_size).flip
                        end
                    end
                    threads.all?(&:join)
                    chunk_collector
                else
                    MiniParallel.map(chunks) do |start, weighted_size|
                        Fannkuch.new(n,start,weighted_size).flip
                    end
                end

            chunk_results.reduce do |memo, (cksum, fmax)|
                [memo[0] + cksum, [memo[1], fmax].max]
            end
        else
            Fannkuch.new(n,0,chunk_size).flip
        end

    printf "%d\nPfannkuchen(%d) = %d\n", sum, n, flips
dependencies:
    - name: ruby_3_4
      version: 3.4.3
roptions:
    - -W0
---
args: [12]
expected_stdout: |
    3968050
    Pfannkuchen(12) = 65
