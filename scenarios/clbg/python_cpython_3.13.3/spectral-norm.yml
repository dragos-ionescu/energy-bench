implementation: python
name: spectral-norm
description: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/spectralnorm.html#spectralnorm
    Compute an approximation of the spectral norm ‖A‖₂ (largest singular value) of the infinite matrix
    - a_{ij} = 1 / ((i + j)(i + j + 1) / 2 + i + 1),    i, j ≥ 0.
    - Initialise a length-N vector u = (1, 1, …, 1)ᵀ.
    - Power-iteration loop – repeat N times:
    - v ← A·u (matrix–vector product on-the-fly)
    - u ← Aᵀ·v (transpose product)
    - Estimate the norm ‖A‖₂ ≈ √((u · v) / (v · v)).
    - Modular helpers to expose A(i,j), Av(u), Atv(v), and spectralNorm(N).
code: | # https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/spectralnorm-python3-4.html
    # The Computer Language Benchmarks Game
    # https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
    #
    # Contributed by Sebastien Loisel
    # Fixed by Isaac Gouy
    # Sped up by Josh Goldfoot
    # Dirtily sped up by Simon Descarpentries
    # Used list comprehension by Vadim Zelenin
    # Concurrency by Jason Stitt
    # Concurrency simplified by Matt Vollrath
    # Optimized math by Adam Beckmeyer


    from itertools import repeat
    from math import sqrt
    from multiprocessing import Pool
    from sys import argv


    def eval_A(i, j):
        ij = i + j
        return ij * (ij + 1) // 2 + i + 1


    def A_sum(u, i):
        return sum(u_j / eval_A(i, j) for j, u_j in enumerate(u))


    def At_sum(u, i):
        return sum(u_j / eval_A(j, i) for j, u_j in enumerate(u))


    def multiply_AtAv(u):
        r = range(len(u))

        tmp = pool.starmap(
            A_sum,
            zip(repeat(u), r)
        )
        return pool.starmap(
            At_sum,
            zip(repeat(tmp), r)
        )


    def main():
        n = int(argv[1])
        u = [1] * n

        for _ in range(10):
            v = multiply_AtAv(u)
            u = multiply_AtAv(v)

        vBv = vv = 0

        for ue, ve in zip(u, v):
            vBv += ue * ve
            vv  += ve * ve

        result = sqrt(vBv/vv)
        print("{0:.9f}".format(result))


    if __name__ == '__main__':
        with Pool(processes=4) as pool:
            main()
dependencies:
    - name: python313
      version: 3.13.3
roptions:
    - -OO
---
args: [5500]
expected_stdout: |
    1.274224153
