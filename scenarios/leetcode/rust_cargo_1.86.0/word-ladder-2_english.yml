implementation: rust
name: word-ladder-2
description: | # https://leetcode.com/problems/word-ladder-ii/description/
    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
    - Every adjacent pair of words differs by a single letter.
    - Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
    - sk == endWord
    Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].

    Example:
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot", "dot", "dog", "lot", "log", "cog"]
    Output: [["hit", "hot", "dot", "dog", "cog"], ["hit", "hot", "lot", "log", "cog"]]
    Explanation: There are 2 shortest transformation sequences:
    "hit" -> "hot" -> "dot" -> "dog" -> "cog"
    "hit" -> "hot" -> "lot" -> "log" -> "cog"

    Constraints:
    - 1 <= beginWord.length <= 5
    - endWord.length == beginWord.length
    - 1 <= wordList.length <= 500
    - wordList[i].length == beginWord.length
    - beginWord, endWord, and wordList[i] consist of lowercase English letters.
    - beginWord != endWord
    - All the words in wordList are unique.
    - The sum of all shortest transformation sequences does not exceed 10⁵.
code: | # https://leetcode.com/problems/word-ladder-ii/solutions/1925798/rust-0ms-solution-bitmap-bfs
    use std::collections::{HashMap, LinkedList};

    pub struct Solution;

    #[inline(always)]
    fn word_to_bits(word: &[u8]) -> u32 {
        let mut res = 0;
        for (i, c) in word.iter().enumerate() {
            res |= ((*c - b'a' + 1) as u32) << (i as u32 * 5);
        }
        res
    }

    #[inline(always)]
    fn clear_loc(word: u32, loc: usize) -> u32 {
        let mask = u32::MAX - (0x1F << (loc * 5));
        word & mask
    }

    #[derive(Default, Debug)]
    struct ResultNode {
        nexts: LinkedList<usize>,
        level: usize,
    }

    impl Solution {
        pub fn find_ladders(
            begin_word: String,
            end_word: String,
            mut word_list: Vec<String>,
        ) -> Vec<Vec<String>> {
            let L = word_list.len();
            let N = begin_word.len();
            let mut words = word_list
                .iter()
                .map(|s| word_to_bits(s.as_bytes()))
                .collect::<Vec<_>>();
            let mut indices = HashMap::<u32, usize>::with_capacity(L + 2);
            for (i, &word) in words.iter().enumerate() {
                indices.insert(word, i);
            }
            let begin_word_ori = begin_word.clone();
            let begin_word = word_to_bits(begin_word.as_bytes());
            let end_word = word_to_bits(end_word.as_bytes());
            let begin_index = *indices.entry(begin_word).or_insert_with(|| {
                words.push(begin_word);
                word_list.push(begin_word_ori);
                word_list.len() - 1
            });
            let end_index = match indices.get(&end_word) {
                Some(&i) => i,
                None => return vec![],
            };

            let mut slots = HashMap::<u32, LinkedList<usize>>::new();
            for (&word, &i) in &indices {
                for j in 0..N {
                    let slot = clear_loc(word, j);
                    slots.entry(slot).or_default().push_front(i);
                }
            }

            if (0..N).all(|j| slots.get(&clear_loc(end_word, j)).unwrap().len() == 1)
                || (0..N).all(|j| slots.get(&clear_loc(begin_word, j)).unwrap().len() == 1)
            {
                return vec![];
            }

            let mut nodes = Vec::<Option<ResultNode>>::with_capacity(L + 2);
            for _ in 0..=L + 1 {
                nodes.push(None);
            }
            nodes[end_index] = Some(ResultNode {
                nexts: LinkedList::new(),
                level: 0,
            });

            let qcap = L + 3;
            let mut q = vec![0; qcap];
            let mut head = 0;
            let mut tail = 1;
            let mut min_length = usize::MAX;
            q[0] = end_index;

            while head != tail {
                let curi = q[head];
                let cur_level = nodes[curi].as_ref().unwrap().level;
                if cur_level >= min_length {
                    break;
                }
                head = (head + 1) % qcap;
                let next_level = cur_level + 1;

                for j in 0..N {
                    let slot_key = clear_loc(words[curi], j);
                    for prev_i in slots.get(&slot_key).unwrap().iter().cloned() {
                        if prev_i == begin_index {
                            min_length = next_level;
                        }
                        if prev_i == curi {
                            continue;
                        }
                        match &mut nodes[prev_i] {
                            None => {
                                let mut list = LinkedList::new();
                                list.push_front(curi);
                                nodes[prev_i] = Some(ResultNode {
                                    nexts: list,
                                    level: next_level,
                                });
                                q[tail] = prev_i;
                                tail = (tail + 1) % qcap;
                            }
                            Some(node) if node.level == next_level => {
                                node.nexts.push_front(curi);
                            }
                            _ => {}
                        }
                    }
                }
            }

            // if BFS never reached begin_index, return empty
            if nodes[begin_index].is_none() {
                return vec![];
            }

            // build all paths
            let mut results = Vec::new();
            let mut path = vec![word_list[begin_index].clone()];
            make_results(begin_index, &word_list, &nodes, &mut path, &mut results);

            // ensure deterministic order
            results.sort();
            results
        }
    }

    fn make_results(
        i: usize,
        word_list: &[String],
        nodes: &[Option<ResultNode>],
        path: &mut Vec<String>,
        results: &mut Vec<Vec<String>>,
    ) {
        let node = nodes[i].as_ref().unwrap();
        if node.nexts.is_empty() {
            results.push(path.clone());
            return;
        }
        for &nexti in node.nexts.iter() {
            path.push(word_list[nexti].clone());
            make_results(nexti, word_list, nodes, path, results);
            path.pop();
        }
    }

    fn main() {
        let args: Vec<String> = std::env::args().skip(1).collect();
        if args.len() < 3 {
            eprintln!("Usage: <begin> <end> <word1> <word2> ...");
            return;
        }
        let begin = args[0].clone();
        let end = args[1].clone();
        let word_list = args[2..].to_vec();
        let ladders = Solution::find_ladders(begin, end, word_list);

        print!("[");
        for (i, seq) in ladders.iter().enumerate() {
            if i > 0 {
                print!(", ");
            }
            print!("[");
            for (j, word) in seq.iter().enumerate() {
                if j > 0 {
                    print!(", ");
                }
                print!("\"{}\"", word);
            }
            print!("]");
        }
        println!("]");
    }
dependencies:
    - name: cargo
      version: 1.86.0
    - name: rustc
      version: 1.86.0
options:
    - --release
    - --config profile.release.codegen-units=1
---
args: ["hit", "cog", "hot", "dot", "dog", "lot", "log", "cog"]
expected_stdout: |
    [["hit", "hot", "dot", "dog", "cog"], ["hit", "hot", "lot", "log", "cog"]]
---
args: ["jbykh", "drgdo", "vrpuk", "sveyt", "rwiql", "wrefl", "cugsm", "olngj", "eiuvg", "xctxz", "vhpvg", "zbzrf", "vxnhz", "mkyfa", "gsjgf", "gbrgy", "iapfw", "euxyz", "jrrok", "vjabe", "bbfal", "rcjet", "bbdep", "sfypv", "kgefu", "uunxu", "aearz", "xzqqo", "vkrdm", "wrdla", "atvyp", "ctekr", "xfbqv", "rfcva", "sfzdp", "sveyt", "hdjqq", "nnqjs", "kducw", "cwvae", "npytc", "urmpc", "nbmnx", "kkaut", "kiodu", "aybji", "wrdla", "jjaxt", "szrxt", "erqay", "ogyxm", "qytzu", "zbzrf", "nkazb", "nydld", "tfguv", "wjaml", "nwhsb", "bigcu", "pgjbo", "tecad", "swnjf", "ltkns", "almuh", "rixhx", "smljp", "wpvbc", "mhkey", "wmqpf", "wytbp", "whwim", "wytbp", "blxhu", "ttbyx", "alfop", "fsrgu", "dxthw", "wvqur", "cdfrl", "wkpoj", "rtdst", "ahqpg", "cdfrl", "oicly", "kkffe", "uyyty", "zkzay", "eqiap", "wybxa", "qxiwd", "oirdf", "wrwdf", "ulqih", "byeit", "qxcqr", "ljcvb", "kljtw", "lrgvz", "ifdns", "adfxj", "ixqwl", "awulw", "qjooo", "ubkdv", "ltihr", "ezrnf", "hlint", "esgir", "ksvev", "iwkqa", "qxiwd", "xziay", "umpeq", "bigcu", "sofpl", "sxtoh", "iefub", "qhtvx", "ugwwi", "crtzu", "renmc", "ciesf", "rzvvk", "gsjgf", "oirdf", "kkffe", "jbhuc", "fixrc", "furzj", "kxiev", "mqthp", "juila", "yekes", "zgcyu", "mxepv", "lnnpr", "zecrd", "rwkcy", "kwrdh", "wvqur", "ztuve", "kducw", "cyacx", "zpxxm", "yxogw", "hlint", "rwiql", "aqrix", "weiha", "abdwb", "ffzys", "apmus", "xorlk", "ikcsj", "jwvbw", "pwwmq", "cyacx", "skrqf", "ipgcb", "ltihr", "bbdep", "nronl", "dlzqs", "rwkcy", "hsnnw", "lrgvz", "jlefz", "vwslr", "hdjqq", "qluxo", "nydld", "iqsnm", "owyno", "awulw", "xqixl", "rysaz", "nrzra", "nsnvu", "rzvvk", "knsig", "swbyn", "sodzm", "nomcc", "tqalg", "ojqkw", "isdvn", "aiebt", "elbio", "thrvc", "enqqv", "wptvt", "vfnsc", "agxyw", "sxibt", "klwre", "appqe", "jjaxt", "pitwc", "mkyfa", "uyyty", "kljtw", "rlsrq", "sodzm", "fvytz", "vfnsc", "rbfat", "gbwak", "dskut", "kjvjs", "xqixl", "hkqap", "whwim", "zbyjt", "qktpd", "nronl", "yqxmo", "smtno", "nrzra", "gbwak", "seivo", "ykdue", "esgir", "rwbdi", "wjaml", "rwiql", "kyhqk", "dfgsb", "oqwas", "atvyp", "hpfba", "jlefz", "mmhbp", "mygtn", "uyhve", "kfttp", "wiswo", "ckkdz", "ltkns", "gfsxn", "vhink", "evdji", "vphbo", "lbvog", "zpxxm", "wekzz", "tqalg", "pwcze", "tuqcg", "sxibt", "vkrdm", "ltkns", "yekes", "ykdue", "cmrty", "efwbz", "kiabn", "irwlr", "dfgsb", "dskut", "ofdck", "ubkdv", "fmvxu", "alfop", "ogyxm", "kfttp", "zpxxm", "rasuv", "phjrk", "crtzu", "sveyt", "qsqjn", "ivjpc", "gchje", "renmc", "fjucx", "tecad", "dtrif", "wytbp", "cwvae", "xszfo", "plbaj", "vidlf", "dufsn", "vrqpc", "qjooo", "gqfix", "fsjif", "lnnpr", "wjaml", "veoic", "atftx", "pshyg", "kvrip", "efwbz", "qlspg", "ojefv", "ibkyl", "mxepv", "lcwxo", "xzqqo", "bbfal", "qfzyc", "oidab", "xoqgp", "yyrqo", "frock", "nzvfn", "zuadb", "jkmhh", "wnvdf", "nnqjs", "hkqap", "sxtoh", "nlhou", "arlyy", "zvbot", "mxepv", "ofdck", "ojqkw", "sodzm", "mxepv", "oidab", "zvbot", "zpxxm", "hckng", "zyoxd", "nronl", "jgiyq", "oktpl", "udsxn", "enqqv", "qxiwd", "qsnwq", "wybxa", "hyscd", "ftfgd", "iqsnm", "hrydo", "ekwyd", "knsig", "fzqmz", "vuyjc", "rysaz", "kkffe", "irwlr", "uyyiz", "wybxa", "dwuzc", "bvpwn", "apdeh", "euxyz", "sddrh", "mygtn", "ykdue", "hdjqq", "ltihr", "nareb", "hwemw", "nronl", "odjfb", "wuwac", "veoic", "rixhx", "iwkqa", "arlyy", "swbyn", "zgcyu", "hqdbq", "hcxed", "dkbqy", "crtzu", "fjivf", "cmrty", "jsqud", "rrzdg", "ycbtc", "vkbwz", "cetgk", "zothm", "baqaq", "almuh", "xzqqo", "wybxa", "wvdmh", "zayfw", "ftfgd", "nfekd", "uunxu", "bigcu", "yxxnm", "yekes", "hpfba", "ykrpj", "bbfal", "dkbqy", "zyoxd", "zvbot", "trbfr", "qmgqk", "mygtn", "rrzdg", "mkyfa", "vkbwz", "mkyfa", "xljtj", "sfzdp", "qmejs", "wakqu", "hqdbq", "almuh", "ztuve", "fixrc", "rwbdi", "zothm", "yqxmo", "qfzyc", "hrydo", "arlyy", "fzish", "vbmzm", "rwbdi", "weiha", "fvytz", "qluxo", "owefa", "kkffe", "vfnsc", "nfekd", "urqzb", "lttld", "nareb", "wybxa", "cusbf", "udpdi", "rlsrq", "rsizk", "fhojz", "zsuph", "lttld", "gyxjh", "crtzu", "nkazb", "vyrlr", "uyhve", "wjaml", "jwvbw", "qjpet", "flipx", "ykrpj", "ycgtn", "iilmu", "qhtvx", "gixev", "nciyb", "ckkdz", "wnvdf", "nkazb", "hwsef", "vqfox", "mbhme", "pwcze", "rsizk", "gabqm", "nfekd", "dskut", "fghzj", "ikcsj", "mqbhr", "byeit", "tmtqp", "ixqwl", "vhink", "rzroo", "oktpl", "xctxz", "jeogv", "jsqud", "ogyxm", "sfzdp", "uyyiz", "nrzra", "wptvt", "xqixl", "bndsl", "ycyto", "alfop", "mqthp", "abdwb", "almuh", "wzxux", "pdcoq"]
expected_stdout: |
    []
---
args: ["e", "z", "g", "r", "c", "l", "n", "g", "b", "c", "h", "m", "r", "f", "s", "r", "k", "n", "p", "n", "e", "m", "y", "o", "a", "w", "r", "j", "y", "o", "c", "i", "x", "w", "h", "k", "o", "z", "o", "t", "e", "u", "k", "o", "e", "l", "n", "e", "y", "s", "c", "h", "q", "v", "c", "r", "r", "v", "r", "n", "g", "l", "y", "p", "a", "u", "e", "i", "v", "z", "a", "t", "e", "l", "z", "a", "h", "a", "x", "n", "s", "s", "k", "r", "k", "e", "y", "t", "r", "g", "s", "u", "h", "s", "v", "e", "n", "o", "o", "k", "m", "i", "l", "c", "s", "w", "q", "h", "b", "v", "s", "g", "r", "m", "c", "d", "p", "m", "x", "j", "s", "j", "v", "x", "q", "c", "d", "j", "g", "w", "v", "i", "u", "m", "y", "l", "j", "e", "u", "q", "u", "a", "i", "b", "t", "c", "c", "w", "t", "d", "i", "o", "b", "i", "f", "v", "a", "v", "h", "w", "j", "k", "u", "n", "u", "c", "d", "v", "c", "k", "u", "a", "m", "e", "i", "l", "m", "a", "j", "c", "s", "c", "r", "y", "r", "t", "z", "a", "r", "u", "n", "m", "s", "r", "z", "d", "m", "z", "j", "v", "t", "j", "a", "x", "g", "r", "v", "y", "v", "c", "k", "s", "p", "n", "w", "x", "r", "o", "t", "m", "g", "g", "h", "z", "m", "c", "c", "u", "w", "v", "m", "t", "j", "d", "m", "j", "k", "t", "c", "j", "e", "e", "l", "b", "j", "o", "o", "l", "s", "b", "k", "w", "e", "l", "w", "m", "l", "i", "r", "f", "m", "i", "r", "e", "n", "t", "r", "k", "e", "u", "c", "j", "t", "a", "h", "q", "c", "u", "b", "d", "l", "k", "n", "x", "x", "y", "f", "o", "t", "o", "s", "l", "k", "h", "r", "z", "z", "l", "z", "d", "n", "h", "j", "b", "c", "a", "a", "f", "m", "g", "a", "r", "y", "y", "m", "o", "y", "h", "a", "r", "t", "f", "y", "c", "r", "i", "x", "m", "h", "s", "i", "j", "s", "w", "n", "k", "e", "c", "i", "h", "w", "o", "x", "k", "a", "j", "f", "r", "d", "x", "p", "h", "r", "k", "m", "g", "b", "v", "e", "k", "r", "c", "f", "s", "t", "a", "f", "g", "s", "a", "y", "r", "a", "h", "e", "d", "c", "c", "u", "c", "e", "a", "u", "u", "o", "k", "v", "w", "s", "r", "i", "c", "g", "t", "o", "f", "g", "g", "k", "v", "s", "z", "i", "b", "f", "a", "z", "i", "c", "y", "b", "i", "q", "e", "b", "x", "n", "e", "h", "g", "p", "y", "j", "f", "r", "h", "z", "o", "x", "j", "s", "s", "m", "y", "e", "g", "q", "a", "a", "c", "q", "q", "r", "y", "v", "e", "a", "d", "s", "s", "c", "o", "r", "c", "r", "i", "z", "n", "y", "c"]
expected_stdout: |
    [["e", "z"]]
