implementation: cs
name: word-ladder-2
description: | # https://leetcode.com/problems/word-ladder-ii/description/
    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
    - Every adjacent pair of words differs by a single letter.
    - Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
    - sk == endWord
    Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].

    Example:
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot", "dot", "dog", "lot", "log", "cog"]
    Output: [["hit", "hot", "dot", "dog", "cog"], ["hit", "hot", "lot", "log", "cog"]]
    Explanation: There are 2 shortest transformation sequences:
    "hit" -> "hot" -> "dot" -> "dog" -> "cog"
    "hit" -> "hot" -> "lot" -> "log" -> "cog"

    Constraints:
    - 1 <= beginWord.length <= 5
    - endWord.length == beginWord.length
    - 1 <= wordList.length <= 500
    - wordList[i].length == beginWord.length
    - beginWord, endWord, and wordList[i] consist of lowercase English letters.
    - beginWord != endWord
    - All the words in wordList are unique.
    - The sum of all shortest transformation sequences does not exceed 10⁵.
code: | # https://leetcode.com/problems/word-ladder-ii/solutions/370368/bfs-in-c-faster-than-63
    using System;
    using System.Diagnostics;
    using System.Collections.Generic;
    using System.Linq;

    public class Solution {
        public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList)
        {
            Func<string, List<Problem>> generateNewWords;
            if (wordList.Count < 26 * beginWord.Length)
            {
                //Let W be word length, L be wordList count。
                //If wordList is short, iterate wordList。
                //Iteration count is L, the complexity of IsDifference1 is W, so overall complexity is  O(WL).
                var enhancedList = wordList.Select(w => new Problem(w)).ToList();
                var words = new List<Problem>(enhancedList);
                generateNewWords = begingWord => (from w in words
                                                  where IsDifference1(w.Word, begingWord)
                                                  select w).ToList();
            }
            else
            {
                //If wordList is long, iterate and change the char in the starting word, then check if the new word is in wordList.
                //Iteration count is 26W, the complexity of IsDifference1 is W, so overall complexity is O(26W^2) -> O(W^2).
                var dic = wordList.ToHashSet();
                generateNewWords = word =>
                {
                    List<Problem> list = new List<Problem>();
                    var charArr = word.ToCharArray();
                    for (int j = 0; j < charArr.Length; j++)
                    {
                        char ch = charArr[j];
                        for (int k = 0; k < 26; k++)
                        {
                            char nextCh = (char)(k + 'a');
                            if (nextCh == ch)
                                continue;

                            charArr[j] = nextCh;
                            string nextWord = new string(charArr);
                            if (dic.Contains(nextWord) && IsDifference1(nextWord, word))
                                list.Add(new Problem(nextWord));
                        }
                        charArr[j] = ch;
                    }
                    return list;
                };
            }
            //Up to here, the complexity of generateNewWords is O(min(WL,W^2)).
            var transforms = FindLadders(new Problem(beginWord), endWord, generateNewWords, wordList.Count);
            //If there is no solution, return empty list as required.
            if (transforms.Count == 0)
                return new List<IList<string>>();
            else
                return transforms
                       .Select(t => (IList<string>)t.ToList())
                       .ToList();
        }

        /// <summary>
        /// </summary>
        /// <returns></returns>
        /// <remarks>
        /// Let the complexity of generateNewWords be g
        /// in the worst case there are L^L nodes, each node needs to check if it's the solution, which is O(W), then expand the node, which is O(min(WL,W^2)).
        /// Therefore, overall complexity is O((W+g)L^L).
        /// </remarks>
        List<LinkedList<string>> FindLadders(Problem beginWord, string endWord, Func<string, List<Problem>> generateNewWords, int wordListCount)
        {
            //Can transform beginWord how many times
            int usedTransformLimit = wordListCount;
            var queue = new Queue<Problem>();
            queue.Enqueue(beginWord);
            var shortestTransformations = new List<LinkedList<string>>();
            var expansionMap = new Dictionary<string, Tuple<int, IList<Problem>>>(wordListCount);

            while (queue.Count > 0)
            {
                var problem = queue.Dequeue();
                if (problem.Word == endWord)
                {
                    var transform = ChainTransform(problem);
                    shortestTransformations.Add(transform);
                    usedTransformLimit = problem.UsedTransform;
                }

                if (problem.UsedTransform == usedTransformLimit)
                    continue;

                if (!expansionMap.TryGetValue(problem.Word, out var nextWords) || nextWords.Item2 == null)
                {
                    nextWords = new Tuple<int, IList<Problem>>(problem.UsedTransform + 1, generateNewWords(problem.Word));
                    expansionMap[problem.Word] = nextWords;
                }

                foreach (var w in nextWords.Item2)
                {
                    var p = new Problem(w.Word, problem);
                    if (!expansionMap.TryGetValue(p.Word, out var v) || v.Item1 >= p.UsedTransform)
                    {
                        queue.Enqueue(p);
                        expansionMap[p.Word] = Tuple.Create(p.UsedTransform, v?.Item2);
                    }
                }
            }

            return shortestTransformations;
        }

        bool IsDifference1(string w1, string w2)
        {
            bool hasDifference = false;
            for (int i = 0; i < w1.Length; i++)
            {
                if (w1[i] != w2[i])
                {
                    if (hasDifference)
                        return false;
                    hasDifference = true;
                }
            }

            return hasDifference;
        }

        LinkedList<string> ChainTransform(Problem p)
        {
            var list = new LinkedList<string>();
            while (p != null)
            {
                list.AddFirst(p.Word);
                p = p.Parent;
            }

            return list;
        }

        //[DebuggerDisplay("Word={Word}, d={DifferenceFromSolution}")]
        class Problem
        {
            public Problem(string word, Problem parent = null)
            {
                Word = word;
                Parent = parent;
                UsedTransform = parent != null ? parent.UsedTransform + 1 : 0;
            }
            public string Word { get; }

            /// <summary>
            /// Transforms used since the beginning
            /// </summary>
            public int UsedTransform { get; }

            public Problem Parent { get; }
        }
    }

    public class Program {
        public static void Main(string[] args) {
            if (args.Length < 3) {
                Console.Error.WriteLine("Usage: Program <beginWord> <endWord> <word1> [word2 ...]");
                return;
            }
            var beginWord = args[0];
            var endWord = args[1];
            var wordList = args.Skip(2).ToList();

            var sol = new Solution();
            var ladders = sol.FindLadders(beginWord, endWord, wordList);

            Console.Write("[");
            for (int i = 0; i < ladders.Count; i++) {
                var path = ladders[i];
                Console.Write("[\"" + path[0] + "\"");
                for (int j = 1; j < path.Count; j++)
                    Console.Write(", \"" + path[j] + "\"");
                Console.Write("]");
                if (i < ladders.Count - 1)
                    Console.Write(", ");
            }
            Console.WriteLine("]");
        }
    }
dependencies:
    - name: dotnet-sdk_9
      version: 9.0.203
target_framework: net9.0
options:
    - -c Release
    - -p:OutputType=Exe
    - -p:ImplicitUsings=enable
    - -p:Nullable=enable
    - -p:AllowUnsafeBlocks=true
    - -p:ServerGarbageCollection=true
    - -p:ConcurrentGarbageCollection=true
    - -p:OptimizationPreference=Speed
    - -p:IlcInstructionSet=native
---
args: ["hit", "cog", "hot", "dot", "dog", "lot", "log", "cog"]
expected_stdout: |
    [["hit", "hot", "dot", "dog", "cog"], ["hit", "hot", "lot", "log", "cog"]]
---
args: ["jbykh", "drgdo", "vrpuk", "sveyt", "rwiql", "wrefl", "cugsm", "olngj", "eiuvg", "xctxz", "vhpvg", "zbzrf", "vxnhz", "mkyfa", "gsjgf", "gbrgy", "iapfw", "euxyz", "jrrok", "vjabe", "bbfal", "rcjet", "bbdep", "sfypv", "kgefu", "uunxu", "aearz", "xzqqo", "vkrdm", "wrdla", "atvyp", "ctekr", "xfbqv", "rfcva", "sfzdp", "sveyt", "hdjqq", "nnqjs", "kducw", "cwvae", "npytc", "urmpc", "nbmnx", "kkaut", "kiodu", "aybji", "wrdla", "jjaxt", "szrxt", "erqay", "ogyxm", "qytzu", "zbzrf", "nkazb", "nydld", "tfguv", "wjaml", "nwhsb", "bigcu", "pgjbo", "tecad", "swnjf", "ltkns", "almuh", "rixhx", "smljp", "wpvbc", "mhkey", "wmqpf", "wytbp", "whwim", "wytbp", "blxhu", "ttbyx", "alfop", "fsrgu", "dxthw", "wvqur", "cdfrl", "wkpoj", "rtdst", "ahqpg", "cdfrl", "oicly", "kkffe", "uyyty", "zkzay", "eqiap", "wybxa", "qxiwd", "oirdf", "wrwdf", "ulqih", "byeit", "qxcqr", "ljcvb", "kljtw", "lrgvz", "ifdns", "adfxj", "ixqwl", "awulw", "qjooo", "ubkdv", "ltihr", "ezrnf", "hlint", "esgir", "ksvev", "iwkqa", "qxiwd", "xziay", "umpeq", "bigcu", "sofpl", "sxtoh", "iefub", "qhtvx", "ugwwi", "crtzu", "renmc", "ciesf", "rzvvk", "gsjgf", "oirdf", "kkffe", "jbhuc", "fixrc", "furzj", "kxiev", "mqthp", "juila", "yekes", "zgcyu", "mxepv", "lnnpr", "zecrd", "rwkcy", "kwrdh", "wvqur", "ztuve", "kducw", "cyacx", "zpxxm", "yxogw", "hlint", "rwiql", "aqrix", "weiha", "abdwb", "ffzys", "apmus", "xorlk", "ikcsj", "jwvbw", "pwwmq", "cyacx", "skrqf", "ipgcb", "ltihr", "bbdep", "nronl", "dlzqs", "rwkcy", "hsnnw", "lrgvz", "jlefz", "vwslr", "hdjqq", "qluxo", "nydld", "iqsnm", "owyno", "awulw", "xqixl", "rysaz", "nrzra", "nsnvu", "rzvvk", "knsig", "swbyn", "sodzm", "nomcc", "tqalg", "ojqkw", "isdvn", "aiebt", "elbio", "thrvc", "enqqv", "wptvt", "vfnsc", "agxyw", "sxibt", "klwre", "appqe", "jjaxt", "pitwc", "mkyfa", "uyyty", "kljtw", "rlsrq", "sodzm", "fvytz", "vfnsc", "rbfat", "gbwak", "dskut", "kjvjs", "xqixl", "hkqap", "whwim", "zbyjt", "qktpd", "nronl", "yqxmo", "smtno", "nrzra", "gbwak", "seivo", "ykdue", "esgir", "rwbdi", "wjaml", "rwiql", "kyhqk", "dfgsb", "oqwas", "atvyp", "hpfba", "jlefz", "mmhbp", "mygtn", "uyhve", "kfttp", "wiswo", "ckkdz", "ltkns", "gfsxn", "vhink", "evdji", "vphbo", "lbvog", "zpxxm", "wekzz", "tqalg", "pwcze", "tuqcg", "sxibt", "vkrdm", "ltkns", "yekes", "ykdue", "cmrty", "efwbz", "kiabn", "irwlr", "dfgsb", "dskut", "ofdck", "ubkdv", "fmvxu", "alfop", "ogyxm", "kfttp", "zpxxm", "rasuv", "phjrk", "crtzu", "sveyt", "qsqjn", "ivjpc", "gchje", "renmc", "fjucx", "tecad", "dtrif", "wytbp", "cwvae", "xszfo", "plbaj", "vidlf", "dufsn", "vrqpc", "qjooo", "gqfix", "fsjif", "lnnpr", "wjaml", "veoic", "atftx", "pshyg", "kvrip", "efwbz", "qlspg", "ojefv", "ibkyl", "mxepv", "lcwxo", "xzqqo", "bbfal", "qfzyc", "oidab", "xoqgp", "yyrqo", "frock", "nzvfn", "zuadb", "jkmhh", "wnvdf", "nnqjs", "hkqap", "sxtoh", "nlhou", "arlyy", "zvbot", "mxepv", "ofdck", "ojqkw", "sodzm", "mxepv", "oidab", "zvbot", "zpxxm", "hckng", "zyoxd", "nronl", "jgiyq", "oktpl", "udsxn", "enqqv", "qxiwd", "qsnwq", "wybxa", "hyscd", "ftfgd", "iqsnm", "hrydo", "ekwyd", "knsig", "fzqmz", "vuyjc", "rysaz", "kkffe", "irwlr", "uyyiz", "wybxa", "dwuzc", "bvpwn", "apdeh", "euxyz", "sddrh", "mygtn", "ykdue", "hdjqq", "ltihr", "nareb", "hwemw", "nronl", "odjfb", "wuwac", "veoic", "rixhx", "iwkqa", "arlyy", "swbyn", "zgcyu", "hqdbq", "hcxed", "dkbqy", "crtzu", "fjivf", "cmrty", "jsqud", "rrzdg", "ycbtc", "vkbwz", "cetgk", "zothm", "baqaq", "almuh", "xzqqo", "wybxa", "wvdmh", "zayfw", "ftfgd", "nfekd", "uunxu", "bigcu", "yxxnm", "yekes", "hpfba", "ykrpj", "bbfal", "dkbqy", "zyoxd", "zvbot", "trbfr", "qmgqk", "mygtn", "rrzdg", "mkyfa", "vkbwz", "mkyfa", "xljtj", "sfzdp", "qmejs", "wakqu", "hqdbq", "almuh", "ztuve", "fixrc", "rwbdi", "zothm", "yqxmo", "qfzyc", "hrydo", "arlyy", "fzish", "vbmzm", "rwbdi", "weiha", "fvytz", "qluxo", "owefa", "kkffe", "vfnsc", "nfekd", "urqzb", "lttld", "nareb", "wybxa", "cusbf", "udpdi", "rlsrq", "rsizk", "fhojz", "zsuph", "lttld", "gyxjh", "crtzu", "nkazb", "vyrlr", "uyhve", "wjaml", "jwvbw", "qjpet", "flipx", "ykrpj", "ycgtn", "iilmu", "qhtvx", "gixev", "nciyb", "ckkdz", "wnvdf", "nkazb", "hwsef", "vqfox", "mbhme", "pwcze", "rsizk", "gabqm", "nfekd", "dskut", "fghzj", "ikcsj", "mqbhr", "byeit", "tmtqp", "ixqwl", "vhink", "rzroo", "oktpl", "xctxz", "jeogv", "jsqud", "ogyxm", "sfzdp", "uyyiz", "nrzra", "wptvt", "xqixl", "bndsl", "ycyto", "alfop", "mqthp", "abdwb", "almuh", "wzxux", "pdcoq"]
expected_stdout: |
    []
---
args: ["e", "z", "g", "r", "c", "l", "n", "g", "b", "c", "h", "m", "r", "f", "s", "r", "k", "n", "p", "n", "e", "m", "y", "o", "a", "w", "r", "j", "y", "o", "c", "i", "x", "w", "h", "k", "o", "z", "o", "t", "e", "u", "k", "o", "e", "l", "n", "e", "y", "s", "c", "h", "q", "v", "c", "r", "r", "v", "r", "n", "g", "l", "y", "p", "a", "u", "e", "i", "v", "z", "a", "t", "e", "l", "z", "a", "h", "a", "x", "n", "s", "s", "k", "r", "k", "e", "y", "t", "r", "g", "s", "u", "h", "s", "v", "e", "n", "o", "o", "k", "m", "i", "l", "c", "s", "w", "q", "h", "b", "v", "s", "g", "r", "m", "c", "d", "p", "m", "x", "j", "s", "j", "v", "x", "q", "c", "d", "j", "g", "w", "v", "i", "u", "m", "y", "l", "j", "e", "u", "q", "u", "a", "i", "b", "t", "c", "c", "w", "t", "d", "i", "o", "b", "i", "f", "v", "a", "v", "h", "w", "j", "k", "u", "n", "u", "c", "d", "v", "c", "k", "u", "a", "m", "e", "i", "l", "m", "a", "j", "c", "s", "c", "r", "y", "r", "t", "z", "a", "r", "u", "n", "m", "s", "r", "z", "d", "m", "z", "j", "v", "t", "j", "a", "x", "g", "r", "v", "y", "v", "c", "k", "s", "p", "n", "w", "x", "r", "o", "t", "m", "g", "g", "h", "z", "m", "c", "c", "u", "w", "v", "m", "t", "j", "d", "m", "j", "k", "t", "c", "j", "e", "e", "l", "b", "j", "o", "o", "l", "s", "b", "k", "w", "e", "l", "w", "m", "l", "i", "r", "f", "m", "i", "r", "e", "n", "t", "r", "k", "e", "u", "c", "j", "t", "a", "h", "q", "c", "u", "b", "d", "l", "k", "n", "x", "x", "y", "f", "o", "t", "o", "s", "l", "k", "h", "r", "z", "z", "l", "z", "d", "n", "h", "j", "b", "c", "a", "a", "f", "m", "g", "a", "r", "y", "y", "m", "o", "y", "h", "a", "r", "t", "f", "y", "c", "r", "i", "x", "m", "h", "s", "i", "j", "s", "w", "n", "k", "e", "c", "i", "h", "w", "o", "x", "k", "a", "j", "f", "r", "d", "x", "p", "h", "r", "k", "m", "g", "b", "v", "e", "k", "r", "c", "f", "s", "t", "a", "f", "g", "s", "a", "y", "r", "a", "h", "e", "d", "c", "c", "u", "c", "e", "a", "u", "u", "o", "k", "v", "w", "s", "r", "i", "c", "g", "t", "o", "f", "g", "g", "k", "v", "s", "z", "i", "b", "f", "a", "z", "i", "c", "y", "b", "i", "q", "e", "b", "x", "n", "e", "h", "g", "p", "y", "j", "f", "r", "h", "z", "o", "x", "j", "s", "s", "m", "y", "e", "g", "q", "a", "a", "c", "q", "q", "r", "y", "v", "e", "a", "d", "s", "s", "c", "o", "r", "c", "r", "i", "z", "n", "y", "c"]
expected_stdout: |
    [["e", "z"]]
