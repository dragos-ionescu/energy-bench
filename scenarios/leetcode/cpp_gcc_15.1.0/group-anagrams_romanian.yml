implementation: cpp
name: gruparea-anagramelor
description: | # https://leetcode.com/problems/group-anagrams/description/
    Dată fiind o listă de șiruri de caractere `strs`, grupează anagramele împreună.
    Poți returna răspunsul în orice ordine.

    Exemplu:
    Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
    Output: [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]

    Explicație:
    - Nu există niciun șir în `strs` care să poată fi rearanjat pentru a forma „bat”.
    - Șirurile „nat” și „tan” sunt anagrame deoarece pot fi rearanjate unul în celălalt.
    - Șirurile „ate”, „eat” și „tea” sunt anagrame deoarece pot fi rearanjate unul în celălalt.

    Constrângeri:
    - 1 <= strs.length <= 10⁴
    - 0 <= strs[i].length <= 100
    - strs[i] conține doar litere mici ale alfabetului englez.
code: | # https://leetcode.com/problems/group-anagrams/solutions/19200/c-unordered-map-and-counting-sort
    #include <iostream>
    #include <vector>
    #include <string>
    #include <unordered_map>
    #include <algorithm>
    using namespace std;

    class Solution {
    public:
        vector<vector<string>> groupAnagrams(vector<string>& strs) {
            unordered_map<string, vector<string>> mp;
            for (string s : strs) {
                string t = s;
                sort(t.begin(), t.end());
                mp[t].push_back(s);
            }
            vector<vector<string>> anagrams;
            for (auto p : mp) {
                anagrams.push_back(p.second);
            }
            return anagrams;
        }
    };

    int main(int argc, char* argv[]) {
        vector<string> input;
        for (int i = 1; i < argc; ++i) {
            input.emplace_back(argv[i]);
        }

        Solution sol;
        auto res = sol.groupAnagrams(input);

        if (res.empty()) {
            cout << "[]\n";
        } else {
            cout << "[";
            for (size_t i = 0; i < res.size(); ++i) {
                if (i) cout << ", ";
                cout << "[";
                for (size_t j = 0; j < res[i].size(); ++j) {
                    if (j) cout << ", ";
                    cout << "\"" << res[i][j] << "\"";
                }
                cout << "]";
            }
            cout << "]\n";
        }
        return 0;
    }
dependencies:
    - name: gcc15
      version: 15.1.0
options:
    - -pipe
    - -O3
    - -march=native
    - -fomit-frame-pointer
---
args: ["x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x"]
expected_stdout: |
    [["x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x", "x"]]
---
args: ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t"]
expected_stdout: |
    [["t"], ["s"], ["r"], ["q"], ["o"], ["a"], ["b"], ["p"], ["h"], ["n"], ["d"], ["k"], ["c"], ["i"], ["f"], ["g"], ["e"], ["j"], ["l"], ["m"]]
---
args: ["ytclsllouu", "hhjm", "vvpzifp", "hdswrgllp", "qbloyuljd", "vwxocb", "mtsrj"]
expected_stdout: |
    [["vwxocb"], ["qbloyuljd"], ["hdswrgllp"], ["vvpzifp"], ["mtsrj"], ["hhjm"], ["ytclsllouu"]]
---
args: ["idgs", "cmkopf", "tvhtnbgwi", "zvri"]
expected_stdout: |
    [["zvri"], ["tvhtnbgwi"], ["cmkopf"], ["idgs"]]
---
args: ["epdwfetvw", "s"]
expected_stdout: |
    [["s"], ["epdwfetvw"]]
